
==================================================
FILE: Thesis/Draft.swift
==================================================

import Foundation

struct Draft: Identifiable, Codable, Equatable {
    let id: UUID
    let name: String
    let content: String
    let timestamp: Date
    let comment: String
    let parentId: UUID?
    let isFirstDraft: Bool
    
    init(name: String, content: String, comment: String = "", parentId: UUID? = nil, isFirstDraft: Bool = false) {
        self.id = UUID()
        self.name = name
        self.content = content
        self.timestamp = Date()
        self.comment = comment
        self.parentId = parentId
        self.isFirstDraft = isFirstDraft
    }
    
    var displayTimestamp: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: timestamp)
    }
    
    var displayName: String {
        if isFirstDraft {
            return "First Draft: \(name)"
        }
        return name
    }
}

// Working draft that auto-saves but isn't committed
struct WorkingDraft: Codable {
    var content: String
    var lastSaved: Date
    
    init(content: String) {
        self.content = content
        self.lastSaved = Date()
    }
}


==================================================
FILE: Thesis/EditorTextView.swift
==================================================

import SwiftUI
import AppKit

struct EditorTextView: NSViewRepresentable {
    @Binding var text: String
    @Binding var mode: EditorMode
    @Binding var cursorPosition: Int
    @Binding var highlightRange: NSRange?
    @Binding var diffChanges: [DiffChange]  // NEW: For diff visualization
    
    let onTextChange: () -> Void
    let onKeyPress: (String, NSEvent.ModifierFlags) -> Void
    let onModeChange: (EditorMode) -> Void  // NEW: Callback for mode changes from delegate
    
    func makeNSView(context: Context) -> NSScrollView {
        // Create scroll view manually to ensure we use our CustomTextView
        let scrollView = NSScrollView()
        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = false
        scrollView.autohidesScrollers = true
        scrollView.borderType = .noBorder
        
        // Create our custom text view with TextKit 1 for reliable cursor control
        // TextKit 2 (default in macOS 13+) ignores shouldDrawInsertionPoint override
        let contentSize = scrollView.contentSize
        let textContainer = NSTextContainer(containerSize: NSSize(width: contentSize.width, height: CGFloat.greatestFiniteMagnitude))
        textContainer.widthTracksTextView = true
        
        let layoutManager = NSLayoutManager()
        layoutManager.addTextContainer(textContainer)
        
        let textStorage = NSTextStorage()
        textStorage.addLayoutManager(layoutManager)
        
        let customTextView = CustomTextView(frame: NSRect(origin: .zero, size: contentSize), textContainer: textContainer)
        customTextView.minSize = NSSize(width: 0, height: contentSize.height)
        customTextView.maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        customTextView.isVerticallyResizable = true
        customTextView.isHorizontallyResizable = false
        customTextView.autoresizingMask = [.width]
        
        customTextView.delegate = context.coordinator
        customTextView.font = NSFont.monospacedSystemFont(ofSize: 14, weight: .regular)
        customTextView.isAutomaticQuoteSubstitutionEnabled = false
        customTextView.isAutomaticDashSubstitutionEnabled = false
        customTextView.isAutomaticSpellingCorrectionEnabled = false
        customTextView.allowsUndo = false
        customTextView.drawsBackground = true
        customTextView.backgroundColor = NSColor.textBackgroundColor
        
        // Configuration for cursor visibility
        customTextView.insertionPointColor = NSColor.controlAccentColor
        customTextView.isSelectable = true
        
        // ALWAYS keep editable = true
        // We simulate "read-only" via delegate interception (see shouldChangeTextIn)
        customTextView.isEditable = true
        
        // Set the text view as the document view
        scrollView.documentView = customTextView
        
        // Set coordinator reference for direct communication
        context.coordinator.textView = customTextView
        customTextView.coordinator = context.coordinator
        
        return scrollView
    }
    
    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = scrollView.documentView as? CustomTextView else { return }
        
        // Sync text
        if textView.string != text {
            textView.string = text
        }
        
        // Sync cursor
        if cursorPosition >= 0 && cursorPosition <= text.count {
            let range = NSRange(location: cursorPosition, length: 0)
            textView.setSelectedRange(range)
            textView.scrollRangeToVisible(range)
        }
        
        // Sync highlights (for delete/change previews)
        if let range = highlightRange {
            textView.showFindIndicator(for: range)
        }
        
        // BUGFIX #1: ALWAYS keep isEditable = true
        // The "read-only" behavior is enforced via shouldChangeTextIn delegate method
        textView.isEditable = true
        textView.isSelectable = true
        textView.currentMode = mode
        
        // Ensure focus
        if textView.window?.firstResponder != textView {
            textView.window?.makeFirstResponder(textView)
        }
        
        // BUGFIX #4: Render diff visualization in comp mode
        if mode == .comp {
            textView.textColor = NSColor.labelColor // Keep text visible
            renderDiffHighlights(textView: textView)
        } else {
            // Clear any diff highlights when not in comp mode
            clearDiffHighlights(textView: textView)
            textView.textColor = NSColor.labelColor
        }
        
        context.coordinator.parent = self
        textView.coordinator = context.coordinator
    }
    
    // MARK: - BUGFIX #4: Diff Rendering
    
    private func renderDiffHighlights(textView: CustomTextView) {
        guard let layoutManager = textView.layoutManager else { return }
        
        let textLength = (textView.string as NSString).length
        let fullRange = NSRange(location: 0, length: textLength)
        
        // Clear existing temporary attributes
        layoutManager.removeTemporaryAttribute(.backgroundColor, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.underlineStyle, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.underlineColor, forCharacterRange: fullRange)
        
        // Apply highlights for diff changes
        for change in diffChanges {
            switch change.type {
            case .addition:
                // Validate range is within bounds
                guard change.range.location + change.range.length <= textLength else {
                    continue
                }
                // Green background for added text
                layoutManager.addTemporaryAttribute(
                    .backgroundColor,
                    value: NSColor.systemGreen.withAlphaComponent(0.3),
                    forCharacterRange: change.range
                )
                
            case .deletion:
                // Show a red underline at the position where text was deleted
                // Use displayRange which indicates where in the new text to show the marker
                if let displayRange = change.displayRange {
                    // Mark a small range (or the character before) with red to indicate deletion occurred here
                    let markerStart = min(displayRange.location, textLength > 0 ? textLength - 1 : 0)
                    let markerLength = min(1, textLength - markerStart)
                    if markerLength > 0 {
                        let markerRange = NSRange(location: markerStart, length: markerLength)
                        layoutManager.addTemporaryAttribute(
                            .backgroundColor,
                            value: NSColor.systemRed.withAlphaComponent(0.2),
                            forCharacterRange: markerRange
                        )
                    }
                }
                
            case .unchanged:
                // No highlighting for unchanged text
                break
            }
        }
    }
    
    private func clearDiffHighlights(textView: CustomTextView) {
        guard let layoutManager = textView.layoutManager else { return }
        let fullRange = NSRange(location: 0, length: (textView.string as NSString).length)
        layoutManager.removeTemporaryAttribute(.backgroundColor, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.underlineStyle, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.underlineColor, forCharacterRange: fullRange)
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EditorTextView
        weak var textView: CustomTextView?
        
        // Track last newline position for paragraph mode
        private var lastNewlinePosition: Int = -1
        
        init(_ parent: EditorTextView) {
            self.parent = parent
            super.init()
        }
        
        func textDidChange(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else { return }
            
            parent.text = textView.string
            parent.cursorPosition = textView.selectedRange().location
            parent.onTextChange()
        }
        
        // MARK: - BUGFIX #2: Synchronous Input Filtering
        // This is the KEY fix for constrained insert mode triggers.
        // By intercepting here, we BLOCK characters BEFORE they enter the text storage.
        
        func textView(_ textView: NSTextView, shouldChangeTextIn affectedCharRange: NSRange, replacementString: String?) -> Bool {
            
            // Handle based on current mode
            switch parent.mode {
            case .freeText:
                // Allow all typing in free text mode
                return true
                
            case .insert(let context):
                guard let input = replacementString else { return true }
                
                // Always allow backspace/deletion
                if input.isEmpty {
                    return true
                }
                
                // BUGFIX #2: Check exit triggers BEFORE allowing the character
                switch context {
                case .word:
                    // Exit on space or newline - ALLOW the space, then exit
                    if input == " " || input == "\n" {
                        // Switch mode asynchronously to avoid state modification during view update
                        DispatchQueue.main.async {
                            self.parent.onModeChange(.edit)
                        }
                        return true  // Allow the space/newline to be typed, then exit
                    }
                    
                case .sentence:
                    // Exit AFTER punctuation - ALLOW the character, then exit
                    if input == "." || input == "!" || input == "?" {
                        DispatchQueue.main.async {
                            self.parent.onModeChange(.edit)
                        }
                        return true  // Allow the punctuation to be typed
                    }
                    
                case .paragraph:
                    // Exit on double newline
                    if input == "\n" {
                        let currentPos = parent.cursorPosition
                        let textLength = (parent.text as NSString).length
                        
                        // Check if the character before cursor is also a newline
                        let hasNewlineBefore = currentPos > 0 && textLength > 0 &&
                            (parent.text as NSString).substring(with: NSRange(location: currentPos - 1, length: 1)) == "\n"
                        
                        if hasNewlineBefore {
                            DispatchQueue.main.async {
                                self.parent.onModeChange(.edit)
                            }
                            lastNewlinePosition = -1
                            return false  // Block the second newline
                        } else {
                            lastNewlinePosition = currentPos
                            return true  // Allow first newline
                        }
                    } else {
                        lastNewlinePosition = -1
                    }
                }
                
                return true  // Allow all other characters in insert mode
                
            case .edit, .comp, .command:
                // BUGFIX #1: Block ALL text changes in non-typing modes
                // This makes the view "virtually read-only" while keeping cursor visible
                return false
            }
        }
        
        func textView(_ textView: NSTextView, doCommandBy commandSelector: Selector) -> Bool {
            // 1. Always Handle ESC in parent
            if commandSelector == #selector(NSResponder.cancelOperation(_:)) {
                parent.onKeyPress("\u{1B}", [])
                return true
            }
            
            // 2. Always Allow Arrow Keys (for navigation in all modes)
            if commandSelector == #selector(NSResponder.moveUp(_:)) ||
               commandSelector == #selector(NSResponder.moveDown(_:)) ||
               commandSelector == #selector(NSResponder.moveLeft(_:)) ||
               commandSelector == #selector(NSResponder.moveRight(_:)) {
                return false
            }
            
            // 3. Mode-Specific Behavior
            switch parent.mode {
            case .insert, .freeText:
                // Allow NSTextView to handle standard commands (Enter, Delete, etc.)
                return false
            default:
                // Intercept all other commands in Edit/Comp modes
                return true
            }
        }
    }
}

// MARK: - Custom NSTextView

class CustomTextView: NSTextView {
    // Track current mode - kept for backwards compatibility but coordinator.parent.mode is source of truth
    var currentMode: EditorMode = .freeText
    
    // Reference to coordinator for direct communication and real-time mode access
    weak var coordinator: EditorTextView.Coordinator?
    
    // Get the actual current mode from the coordinator's parent binding (real-time)
    private var actualMode: EditorMode {
        return coordinator?.parent.mode ?? currentMode
    }
    
    override var acceptsFirstResponder: Bool {
        return true
    }
    
    override func keyDown(with event: NSEvent) {
        let mode = actualMode  // Use binding-backed mode for real-time accuracy
        
        // Handle ESC specially - always send to parent
        if event.keyCode == 53 { // ESC key
            coordinator?.parent.onKeyPress("\u{1B}", event.modifierFlags)
            return
        }
        
        // For edit/comp/command modes, intercept ALL keys and send to parent handler
        switch mode {
        case .edit, .comp, .command:
            if let characters = event.characters {
                coordinator?.parent.onKeyPress(characters, event.modifierFlags)
            }
            // Do NOT call super (suppress system beep/input)
            return
            
        case .insert, .freeText:
            // For insert/freeText modes, let NSTextView handle normally
            // The shouldChangeTextIn delegate will filter based on context
            super.keyDown(with: event)
        }
    }
    
    // Always draw insertion point (for Bug #1 fix)
    override var shouldDrawInsertionPoint: Bool {
        return true
    }
    
    override func updateInsertionPointStateAndRestartTimer(_ restartTimer: Bool) {
        super.updateInsertionPointStateAndRestartTimer(restartTimer)
        needsDisplay = true
    }
}


==================================================
FILE: Thesis/DraftHistoryView.swift
==================================================

import SwiftUI

struct DraftHistoryView: View {
    let document: Document
    let onRestore: (Draft) -> Void
    let onClose: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack {
                Text("Evolution Timeline")
                    .font(.headline)
                Spacer()
                Button(action: onClose) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
            }
            .padding()
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            // Draft list
            if document.drafts.isEmpty {
                VStack(spacing: 12) {
                    Image(systemName: "clock.badge.exclamationmark")
                        .font(.system(size: 48))
                        .foregroundColor(.secondary)
                    Text("No drafts saved yet")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    Text("Press ESC to save your first draft")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 12) {
                        ForEach(document.drafts.reversed()) { draft in
                            DraftRow(
                                draft: draft,
                                isCurrent: draft.id == document.latestDraft?.id,
                                onRestore: { onRestore(draft) }
                            )
                        }
                    }
                    .padding()
                }
            }
        }
    }
}

struct DraftRow: View {
    let draft: Draft
    let isCurrent: Bool
    let onRestore: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                // Timeline indicator
                Circle()
                    .fill(isCurrent ? Color.blue : Color.gray)
                    .frame(width: 10, height: 10)
                
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text(draft.displayName)
                            .font(.system(size: 14, weight: .semibold))
                        
                        if isCurrent {
                            Text("CURRENT")
                                .font(.system(size: 10, weight: .bold))
                                .foregroundColor(.white)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(Color.blue)
                                .cornerRadius(3)
                        }
                        
                        Spacer()
                        
                        if !isCurrent {
                            Button("Restore") {
                                onRestore()
                            }
                            .buttonStyle(.borderless)
                            .font(.system(size: 11))
                        }
                    }
                    
                    if !draft.comment.isEmpty {
                        Text(draft.comment)
                            .font(.system(size: 12))
                            .foregroundColor(.secondary)
                    }
                    
                    Text(draft.displayTimestamp)
                        .font(.system(size: 11, design: .monospaced))
                        .foregroundColor(.secondary)
                }
            }
            
            // Preview of content (first line)
            Text(draft.content.components(separatedBy: .newlines).first ?? "")
                .font(.system(size: 11, design: .monospaced))
                .foregroundColor(.secondary)
                .lineLimit(1)
                .padding(.leading, 20)
        }
        .padding(12)
        .background(isCurrent ? Color.blue.opacity(0.1) : Color(NSColor.controlBackgroundColor).opacity(0.5))
        .cornerRadius(8)
    }
}


==================================================
FILE: Thesis/ThesisApp.swift
==================================================

import SwiftUI

@main
struct ThesisApp: App {
    @StateObject private var documentManager = DocumentManager()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(documentManager)
                .frame(minWidth: 900, minHeight: 600)
        }
        .commands {
            CommandGroup(replacing: .newItem) {
                Button("New Thought") {
                    documentManager.createNewDocument()
                }
                .keyboardShortcut("n", modifiers: .command)
            }
        }
    }
}


==================================================
FILE: Thesis/DocumentManager.swift
==================================================

import Foundation
import Combine

class DocumentManager: ObservableObject {
    @Published var documents: [Document] = []
    @Published var selectedDocument: Document?
    
    private let saveKey = "ThesisDocumentsMVP"
    private var cancellables = Set<AnyCancellable>()
    private var autoSaveTimer: Timer?
    
    init() {
        loadDocuments()
        setupAutoSave()
    }
    
    private func setupAutoSave() {
        // Auto-save every 30 seconds
        autoSaveTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { [weak self] _ in
            self?.saveDocuments()
        }
    }
    
    func createNewDocument() {
        let doc = Document()
        documents.append(doc)
        selectedDocument = doc
        saveDocuments()
    }
    
    func deleteDocument(_ document: Document) {
        documents.removeAll { $0.id == document.id }
        if selectedDocument?.id == document.id {
            selectedDocument = documents.first
        }
        saveDocuments()
    }
    
    func saveDocuments() {
        do {
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            let data = try encoder.encode(documents)
            UserDefaults.standard.set(data, forKey: saveKey)
        } catch {
            print("Failed to save documents: \(error)")
        }
    }
    
    private func loadDocuments() {
        guard let data = UserDefaults.standard.data(forKey: saveKey) else {
            createWelcomeDocument()
            return
        }
        
        do {
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            documents = try decoder.decode([Document].self, from: data)
            selectedDocument = documents.first
        } catch {
            print("Failed to load documents: \(error)")
            createWelcomeDocument()
        }
    }
    
    private func createWelcomeDocument() {
        let welcome = Document(title: "Welcome to Thesis")
        welcome.currentContent = """
Welcome to Thesis - A modal editor for thought evolution.

You are currently in INSERT mode. Type freely to capture your thoughts.

When ready, press ESC. You'll be prompted to save this as your First Draft.

After saving, you'll enter EDIT mode where you can:
- Navigate: h (prev sentence), l (next sentence), j (next para), k (prev para)
- Delete: dw (word), das (sentence), dap (paragraph), D (to end of sentence)
- Change: cw (word), cas (sentence), cap (paragraph), C (to end of sentence)
- Insert: i (insert word), a (append sentence)
- Undo: u (undo last 10 commands)

To review your changes:
- Type :comp or press Cmd+D to see a diff view
- Use n (next change) and p (previous change) to navigate
- Type :print or press Cmd+S to save as a new draft

Try editing this document to learn the workflow!
"""
        documents.append(welcome)
        selectedDocument = welcome
        saveDocuments()
    }
    
    deinit {
        autoSaveTimer?.invalidate()
    }
}


==================================================
FILE: Thesis/TextAnalyzer.swift
==================================================

import Foundation
import NaturalLanguage

struct TextUnit {
    let range: NSRange
    let text: String
}

class TextAnalyzer {
    
    // MARK: - Sentence Detection
    
    static func getSentences(in text: String) -> [TextUnit] {
        var sentences: [TextUnit] = []
        let nsText = text as NSString
        
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        tagger.enumerateTags(in: text.startIndex..<text.endIndex,
                            unit: .sentence,
                            scheme: .lexicalClass) { _, range in
            let nsRange = NSRange(range, in: text)
            let sentenceText = nsText.substring(with: nsRange)
            sentences.append(TextUnit(range: nsRange, text: sentenceText))
            return true
        }
        
        return sentences
    }
    
    static func getSentenceAt(position: Int, in text: String) -> TextUnit? {
        let sentences = getSentences(in: text)
        return sentences.first { NSLocationInRange(position, $0.range) }
    }
    
    static func getNextSentence(from position: Int, in text: String) -> TextUnit? {
        let sentences = getSentences(in: text)
        return sentences.first { $0.range.location > position }
    }
    
    static func getPreviousSentence(from position: Int, in text: String) -> TextUnit? {
        let sentences = getSentences(in: text)
        return sentences.last { $0.range.location < position }
    }
    
    // MARK: - Paragraph Detection
    
    static func getParagraphs(in text: String) -> [TextUnit] {
        var paragraphs: [TextUnit] = []
        let nsText = text as NSString
        
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        tagger.enumerateTags(in: text.startIndex..<text.endIndex,
                            unit: .paragraph,
                            scheme: .lexicalClass) { _, range in
            let nsRange = NSRange(range, in: text)
            let paragraphText = nsText.substring(with: nsRange)
            
            // Only include non-empty paragraphs
            if !paragraphText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                paragraphs.append(TextUnit(range: nsRange, text: paragraphText))
            }
            return true
        }
        
        return paragraphs
    }
    
    static func getParagraphAt(position: Int, in text: String) -> TextUnit? {
        let paragraphs = getParagraphs(in: text)
        return paragraphs.first { NSLocationInRange(position, $0.range) }
    }
    
    static func getNextParagraph(from position: Int, in text: String) -> TextUnit? {
        let paragraphs = getParagraphs(in: text)
        return paragraphs.first { $0.range.location > position }
    }
    
    static func getPreviousParagraph(from position: Int, in text: String) -> TextUnit? {
        let paragraphs = getParagraphs(in: text)
        return paragraphs.last { $0.range.location < position }
    }
    
    // MARK: - Word Detection
    
    static func getWords(in text: String) -> [TextUnit] {
        var words: [TextUnit] = []
        let nsText = text as NSString
        
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        tagger.enumerateTags(in: text.startIndex..<text.endIndex,
                            unit: .word,
                            scheme: .lexicalClass) { _, range in
            let nsRange = NSRange(range, in: text)
            let wordText = nsText.substring(with: nsRange)
            words.append(TextUnit(range: nsRange, text: wordText))
            return true
        }
        
        return words
    }
    
    static func getWordAt(position: Int, in text: String) -> TextUnit? {
        let words = getWords(in: text)
        return words.first { NSLocationInRange(position, $0.range) }
    }
    
    static func getNextWord(from position: Int, in text: String) -> TextUnit? {
        let words = getWords(in: text)
        return words.first { $0.range.location > position }
    }
    
    static func getPreviousWord(from position: Int, in text: String) -> TextUnit? {
        let words = getWords(in: text)
        return words.last { $0.range.location < position }
    }
    
    // MARK: - Helper Methods
    
    static func getRestOfSentence(from position: Int, in text: String) -> TextUnit? {
        guard let sentence = getSentenceAt(position: position, in: text) else { return nil }
        
        let restStart = position
        let restEnd = sentence.range.location + sentence.range.length
        let restRange = NSRange(location: restStart, length: restEnd - restStart)
        
        let nsText = text as NSString
        let restText = nsText.substring(with: restRange)
        
        return TextUnit(range: restRange, text: restText)
    }
    
    // MARK: - Additional Helper for Word Boundaries
    
    static func getForwardWord(from position: Int, in text: String) -> TextUnit? {
        let words = getWords(in: text)
        
        // Find the word that starts at or after the current position
        if let currentWord = words.first(where: { $0.range.location >= position }) {
            return currentWord
        }
        
        // If cursor is inside a word, get the next word
        return words.first { $0.range.location > position }
    }
    
    static func getBackwardWord(from position: Int, in text: String) -> TextUnit? {
        let words = getWords(in: text)
        
        // Find the word that ends at or before the current position
        return words.last { $0.range.location + $0.range.length <= position }
    }
}


==================================================
FILE: Thesis/ModalEditor.swift
==================================================

import SwiftUI
import AppKit

// MARK: - TextStats (needed for StatusBar)
struct TextStats {
    let paragraphCount: Int
    let sentenceCount: Int
    let wordCount: Int
}

struct ModalEditor: View {
    @Binding var document: Document
    @State private var mode: EditorMode = .freeText  // Start in FREE TEXT
    @State private var commandBuffer: String = ""
    @State private var insertContext: InsertContext?
    @State private var lastNewlinePosition: Int = -1  // For paragraph mode
    @State private var pendingCommand: PendingCommand?
    @State private var highlightRange: NSRange?
    @State private var cursorPosition: Int = 0
    @State private var undoStack = UndoStack()
    @State private var showingFirstDraftSheet = false
    @State private var showingPrintSheet = false
    @State private var diffChanges: [DiffChange] = []
    @State private var currentDiffIndex: Int = 0
    @State private var stats: TextStats = TextStats(paragraphCount: 0, sentenceCount: 0, wordCount: 0)
    
    var body: some View {
        VStack(spacing: 0) {
            // Main editor area
            ZStack {
                EditorTextView(
                    text: $document.currentContent,
                    mode: $mode,
                    cursorPosition: $cursorPosition,
                    highlightRange: $highlightRange,
                    diffChanges: $diffChanges,  // BUGFIX #4: Pass diff changes for rendering
                    onTextChange: { handleTextChange() },
                    onKeyPress: { key, modifiers in handleKeyPress(key, modifiers: modifiers) },
                    onModeChange: { newMode in handleModeChange(newMode) }  // BUGFIX #2: Handle mode changes from delegate
                )
                .border(mode.borderColor, width: 3)
            }
            
            // Status bar
            StatusBar(
                mode: mode,
                commandBuffer: commandBuffer,
                stats: stats,
                draftInfo: draftInfo,
                hasUnsavedChanges: document.hasUnsavedChanges,
                branchInfo: branchInfo,
                diffInfo: currentDiffInfo
            )
        }
        .onAppear {
            DispatchQueue.main.async {
                updateStats()
            }
            // Start in FREE TEXT if no drafts, EDIT if we have drafts
            if !document.drafts.isEmpty {
                mode = .edit
            }
        }
        .sheet(isPresented: $showingFirstDraftSheet) {
            FirstDraftSheet(
                onSave: { name in
                    document.saveFirstDraft(name: name)
                    mode = .edit
                    showingFirstDraftSheet = false
                },
                onCancel: {
                    mode = .freeText
                    showingFirstDraftSheet = false
                }
            )
        }
        .sheet(isPresented: $showingPrintSheet) {
            PrintDraftSheet(
                onSave: { name, comment in
                    document.saveDraft(name: name, comment: comment)
                    mode = .edit
                    showingPrintSheet = false
                    updateStats()
                }
            )
        }
    }
    
    private var draftInfo: String {
        if let latest = document.latestDraft {
            return latest.displayName
        }
        return "No draft saved"
    }
    
    // BUGFIX #3: Display branch information
    private var branchInfo: String? {
        if document.isBranching, let parent = document.currentBranchParent {
            return "Branching from: \(parent.name)"
        }
        return nil
    }
    
    // Diff info for comp mode status bar
    private var currentDiffInfo: StatusBar.DiffInfo? {
        guard mode == .comp, !diffChanges.isEmpty else { return nil }
        
        let changeIndices = DiffGenerator.getChangeIndices(in: diffChanges)
        guard !changeIndices.isEmpty else { return nil }
        
        // Find which change index we're at
        let currentChangeArrayIndex = changeIndices.firstIndex(of: currentDiffIndex) ?? 0
        
        return StatusBar.DiffInfo(
            currentIndex: currentChangeArrayIndex,
            totalChanges: changeIndices.count,
            currentChange: currentDiffIndex < diffChanges.count ? diffChanges[currentDiffIndex] : nil
        )
    }
    
    private func updateStats() {
        // Calculate stats using TextAnalyzer
        let paragraphs = TextAnalyzer.getParagraphs(in: document.currentContent)
        let sentences = TextAnalyzer.getSentences(in: document.currentContent)
        let words = TextAnalyzer.getWords(in: document.currentContent)
        
        // Create the stats object
        let newStats = TextStats(
            paragraphCount: paragraphs.count,
            sentenceCount: sentences.count,
            wordCount: words.count
        )
        
        // FIX: Defer state modification to avoid "modifying state during view update"
        DispatchQueue.main.async {
            self.stats = newStats
        }
    }

    private func handleTextChange() {
        DispatchQueue.main.async {
            self.updateStats()
        }
        
        // Use a switch to match .edit OR any case of .insert
        switch mode {
        case .insert, .edit:
            document.updateWorkingDraft()
        default:
            break
        }
    }
    
    // BUGFIX #2: Handle mode changes triggered by the delegate
    private func handleModeChange(_ newMode: EditorMode) {
        mode = newMode
        if newMode == .edit {
            insertContext = nil
            lastNewlinePosition = -1
        }
    }
    
    private func handleKeyPress(_ characters: String, modifiers: NSEvent.ModifierFlags) {
        // Handle Cmd+D for comp mode (only in EDIT mode)
        if modifiers.contains(.command) && characters == "d" && mode == .edit {
            enterCompMode()
            return
        }
        
        // Handle Cmd+S for print (only in EDIT mode)
        if modifiers.contains(.command) && characters == "s" && mode == .edit {
            if document.latestDraft != nil {
                showingPrintSheet = true
            }
            return
        }
        
        switch mode {
        case .freeText:
            handleFreeTextMode(characters)
        case .edit:
            handleEditMode(characters, modifiers: modifiers)
        case .insert(let context):
            handleInsertMode(characters, context: context)
        case .command(let current):
            handleCommandMode(characters, current: current)
        case .comp:
            handleCompMode(characters)
        }
    }

    // MARK: - FREE TEXT Mode Handler

    private func handleFreeTextMode(_ characters: String) {
        // Only ESC exits - everything else is passed to editor
        if characters == "\u{1B}" { // ESC
            if !document.currentContent.isEmpty {
                showingFirstDraftSheet = true
            }
        }
        // All other keys pass through naturally
    }
    
    // MARK: - Insert Mode
    // Note: Exit trigger logic is now handled in EditorTextView.Coordinator.shouldChangeTextIn
    // This handler is now simplified since the delegate handles exit conditions

    private func handleInsertMode(_ characters: String, context: InsertContext) {
        // ESC always exits to EDIT
        if characters == "\u{1B}" {
            mode = .edit
            insertContext = nil
            return
        }
        
        // All other character handling is done by the delegate's shouldChangeTextIn
        // The delegate blocks/allows characters and triggers mode changes as needed
    }

    // MARK: - Edit Mode

    private func handleEditMode(_ characters: String, modifiers: NSEvent.ModifierFlags) {
        guard let char = characters.first else { return }
        
        // Check for multi-character commands first
        if !commandBuffer.isEmpty {
            let combined = commandBuffer + String(char)
            
            // Two-character commands
            if combined == "dw" {
                executeDeleteWord(forward: true)
                commandBuffer = ""
                return
            } else if combined == "db" {
                executeDeleteWord(forward: false)
                commandBuffer = ""
                return
            } else if combined == "cw" {
                executeChangeWord()
                commandBuffer = ""
                return
            }
            
            // Partial three-character commands
            if combined == "da" || combined == "ca" {
                commandBuffer = combined
                return
            }
            
            // Complete three-character commands
            if combined == "das" {
                executeDeleteSentence()
                commandBuffer = ""
                return
            } else if combined == "dap" {
                executeDeleteParagraph()
                commandBuffer = ""
                return
            } else if combined == "cas" {
                executeChangeSentence()
                commandBuffer = ""
                return
            } else if combined == "cap" {
                executeChangeParagraph()
                commandBuffer = ""
                return
            }
            
            // Invalid combination - clear and process as single
            commandBuffer = ""
        }
        
        // Single character commands
        switch char {
        case "h":
            moveToPreviousSentence()
            
        case "l":
            moveToNextSentence()
            
        case "j":
            moveToNextParagraph()
            
        case "k":
            moveToPreviousParagraph()
            
        case "w":
            if commandBuffer.isEmpty {
                moveToNextWord()
            }
            // If buffer has 'd' or 'c', this completes 'dw' or 'cw' (handled above)
            
        case "b":
            if commandBuffer.isEmpty {
                moveToPreviousWord()
            }
            // If buffer has 'd', this completes 'db' (handled above)
            
        case "d":
            if modifiers.contains(.shift) {
                executeDeleteToEnd()
            } else {
                commandBuffer = "d"
            }
            
        case "c":
            if modifiers.contains(.shift) {
                executeChangeToEnd()
            } else {
                commandBuffer = "c"
            }
            
        case "i":
            mode = .insert(.word)
            insertContext = .word
            commandBuffer = ""
            
        case "a":
            if commandBuffer.isEmpty {
                mode = .insert(.sentence)
                insertContext = .sentence
            }
            // If buffer is 'd' or 'c', keep waiting for 's' or 'p'
            
        case "s":
            // Only valid after 'da' or 'ca'
            // Will be handled by multi-char check above
            break
            
        case "p":
            // Only valid after 'da' or 'ca'
            // Will be handled by multi-char check above
            break
            
        case "u":
            executeUndo()
            commandBuffer = ""
            
        case ":":
            mode = .command("")
            commandBuffer = ""
            
        default:
            commandBuffer = ""
        }
    }
    
    // MARK: - Navigation Commands
    
    private func moveToPreviousSentence() {
        if let prev = TextAnalyzer.getPreviousSentence(from: cursorPosition, in: document.currentContent) {
            cursorPosition = prev.range.location
        }
    }

    private func moveToNextSentence() {
        if let next = TextAnalyzer.getNextSentence(from: cursorPosition, in: document.currentContent) {
            cursorPosition = next.range.location
        }
    }

    private func moveToPreviousParagraph() {
        if let prev = TextAnalyzer.getPreviousParagraph(from: cursorPosition, in: document.currentContent) {
            cursorPosition = prev.range.location
        }
    }

    private func moveToNextParagraph() {
        if let next = TextAnalyzer.getNextParagraph(from: cursorPosition, in: document.currentContent) {
            cursorPosition = next.range.location
        }
    }

    private func moveToNextWord() {
        let words = TextAnalyzer.getWords(in: document.currentContent)
        
        // Find the current word (if cursor is inside one)
        let currentWordEnd = words.first(where: {
            NSLocationInRange(cursorPosition, $0.range)
        }).map { $0.range.location + $0.range.length } ?? cursorPosition
        
        // Find the first word that starts AT OR AFTER the end of current word
        if let nextWord = words.first(where: { $0.range.location >= currentWordEnd }) {
            cursorPosition = nextWord.range.location
        }
    }

    private func moveToPreviousWord() {
        let words = TextAnalyzer.getWords(in: document.currentContent)
        
        // Find the last word that starts BEFORE the current cursor position
        // If we're at the start of a word, go to the previous word
        if let prevWord = words.last(where: { $0.range.location < cursorPosition }) {
            cursorPosition = prevWord.range.location
        }
    }
    
    // MARK: - Delete Commands
    
    private func executeDeleteWord(forward: Bool) {
        let words = TextAnalyzer.getWords(in: document.currentContent)
        let nsText = document.currentContent as NSString
        
        if forward {
            // Find word at or after cursor
            guard let word = words.first(where: { $0.range.location >= cursorPosition }) else { return }
            
            // Calculate range including trailing space
            var deleteRange = word.range
            let endPos = deleteRange.location + deleteRange.length
            
            // Include trailing space if it exists
            if endPos < nsText.length {
                let nextChar = nsText.substring(with: NSRange(location: endPos, length: 1))
                if nextChar == " " || nextChar == "\n" {
                    deleteRange.length += 1
                }
            }
            
            highlightRangeBriefly(deleteRange) {
                self.deleteRange(deleteRange)
            }
            
        } else {
            // Find word before cursor
            guard let word = words.last(where: { $0.range.location + $0.range.length <= cursorPosition }) else { return }
            
            // Calculate range including leading space
            var deleteRange = word.range
            
            // Include leading space if it exists
            if deleteRange.location > 0 {
                let prevChar = nsText.substring(with: NSRange(location: deleteRange.location - 1, length: 1))
                if prevChar == " " || prevChar == "\n" {
                    deleteRange.location -= 1
                    deleteRange.length += 1
                }
            }
            
            highlightRangeBriefly(deleteRange) {
                self.deleteRange(deleteRange)
            }
        }
    }
    
    private func executeDeleteSentence() {
        guard let sentence = TextAnalyzer.getSentenceAt(position: cursorPosition, in: document.currentContent) else { return }
        
        highlightRangeBriefly(sentence.range) {
            deleteRange(sentence.range)
        }
    }
    
    private func executeDeleteParagraph() {
        guard let paragraph = TextAnalyzer.getParagraphAt(position: cursorPosition, in: document.currentContent) else { return }
        
        highlightRangeBriefly(paragraph.range) {
            deleteRange(paragraph.range)
        }
    }
    
    private func executeDeleteToEnd() {
        guard let rest = TextAnalyzer.getRestOfSentence(from: cursorPosition, in: document.currentContent) else { return }
        
        highlightRangeBriefly(rest.range) {
            deleteRange(rest.range)
        }
    }
    
    private func deleteRange(_ range: NSRange) {
        let beforeContent = document.currentContent
        let nsText = beforeContent as NSString
        let afterContent = nsText.replacingCharacters(in: range, with: "")
        
        let command = UndoCommand(
            beforeContent: beforeContent,
            afterContent: afterContent,
            cursorBefore: cursorPosition,
            cursorAfter: range.location
        )
        
        undoStack.push(command)
        document.currentContent = afterContent
        cursorPosition = range.location
        handleTextChange()
    }
    
    // MARK: - Change Commands
    
    private func executeChangeWord() {
        let words = TextAnalyzer.getWords(in: document.currentContent)
        
        // Find word at or immediately after cursor
        guard let word = words.first(where: {
            $0.range.location >= cursorPosition ||
            NSLocationInRange(cursorPosition, $0.range)
        }) else { return }
        
        highlightRangeBriefly(word.range) {
            deleteRange(word.range)
            mode = .insert(.word)
            insertContext = .word
        }
    }


    private func executeChangeSentence() {
        guard let sentence = TextAnalyzer.getSentenceAt(position: cursorPosition, in: document.currentContent) else { return }
        
        highlightRangeBriefly(sentence.range) {
            deleteRange(sentence.range)
            mode = .insert(.sentence)
            insertContext = .sentence
        }
    }

    private func executeChangeParagraph() {
        guard let paragraph = TextAnalyzer.getParagraphAt(position: cursorPosition, in: document.currentContent) else { return }
        
        highlightRangeBriefly(paragraph.range) {
            deleteRange(paragraph.range)
            mode = .insert(.paragraph)
            insertContext = .paragraph
        }
    }

    private func executeChangeToEnd() {
        guard let rest = TextAnalyzer.getRestOfSentence(from: cursorPosition, in: document.currentContent) else { return }
        
        highlightRangeBriefly(rest.range) {
            deleteRange(rest.range)
            mode = .insert(.sentence)
            insertContext = .sentence
        }
    }
    
    // MARK: - Undo
    
    private func executeUndo() {
        guard let command = undoStack.pop() else { return }
        
        if let newPosition = command.undo(in: &document.currentContent) {
            cursorPosition = newPosition
            handleTextChange()
        }
    }
    
    // MARK: - Comp Mode
    
    private func enterCompMode() {
        guard let latestDraft = document.latestDraft else { return }
        
        diffChanges = DiffGenerator.generateDiff(
            from: latestDraft.content,
            to: document.currentContent
        )
        currentDiffIndex = 0
        mode = .comp
        
        // BUGFIX #4: Navigate to first change if any
        if let firstChangeIndex = DiffGenerator.getChangeIndices(in: diffChanges).first {
            currentDiffIndex = firstChangeIndex
            // Move cursor to the first change
            if currentDiffIndex < diffChanges.count {
                cursorPosition = diffChanges[currentDiffIndex].range.location
            }
        }
    }
    
    private func handleCompMode(_ characters: String) {
        guard let char = characters.first else { return }
        
        switch char {
        case "n":
            // Next change
            if let next = DiffGenerator.findNextChange(from: currentDiffIndex, in: diffChanges) {
                currentDiffIndex = next
                // Move cursor to the change (use displayRange for deletions)
                if currentDiffIndex < diffChanges.count {
                    let change = diffChanges[currentDiffIndex]
                    if change.type == .deletion, let displayRange = change.displayRange {
                        cursorPosition = displayRange.location
                    } else {
                        cursorPosition = change.range.location
                    }
                }
            }
            
        case "p":
            // Previous change
            if let prev = DiffGenerator.findPreviousChange(from: currentDiffIndex, in: diffChanges) {
                currentDiffIndex = prev
                // Move cursor to the change (use displayRange for deletions)
                if currentDiffIndex < diffChanges.count {
                    let change = diffChanges[currentDiffIndex]
                    if change.type == .deletion, let displayRange = change.displayRange {
                        cursorPosition = displayRange.location
                    } else {
                        cursorPosition = change.range.location
                    }
                }
            }
            
        case "\u{1B}": // ESC
            mode = .edit
            diffChanges = []  // Clear diff data (and highlights via updateNSView)
            
        default:
            break
        }
    }
    
    // MARK: - Command Mode
    
    private func handleCommandMode(_ characters: String, current: String) {
        guard let char = characters.first else { return }
        
        if char == "\u{1B}" { // ESC
            mode = .edit
            return
        }
        
        if char == "\r" || char == "\n" { // Return
            executeCommand(current)
            return
        }
        
        // Add character to command string
        mode = .command(current + String(char))
    }

    private func executeCommand(_ cmd: String) {
        switch cmd {
        case "comp":
            enterCompMode()
            
        case "print":
            if document.latestDraft != nil {
                showingPrintSheet = true
            }
            mode = .edit
            
        default:
            mode = .edit
        }
    }
    
    // MARK: - Helpers
    
    private func highlightRangeBriefly(_ range: NSRange, completion: @escaping () -> Void) {
        highlightRange = range
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            highlightRange = nil
            completion()
        }
    }
}

// MARK: - Supporting Types

struct PendingCommand {
    let type: PendingCommandType
    let startPosition: Int
}

enum PendingCommandType {
    case insertWord
    case appendSentence
    case change(replacedText: String, range: NSRange, exitOn: ExitCondition)
}

enum ExitCondition {
    case space
    case punctuation
    case doubleNewline
}

// MARK: - Status Bar

struct StatusBar: View {
    let mode: EditorMode
    let commandBuffer: String
    let stats: TextStats
    let draftInfo: String
    let hasUnsavedChanges: Bool
    let branchInfo: String?  // BUGFIX #3: Show branch info
    let diffInfo: DiffInfo?  // Show current change info in comp mode
    
    struct DiffInfo {
        let currentIndex: Int
        let totalChanges: Int
        let currentChange: DiffChange?
    }
    
    var body: some View {
        HStack(spacing: 16) {
            // Mode indicator
            Text(mode.displayName)
                .font(.system(size: 12, weight: .bold, design: .monospaced))
                .foregroundColor(.white)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(mode.borderColor)
                .cornerRadius(4)
            
            // Command buffer
            if !commandBuffer.isEmpty {
                Text(commandBuffer)
                    .font(.system(size: 12, design: .monospaced))
                    .foregroundColor(.secondary)
            }
            
            // Diff info (in comp mode)
            if let diff = diffInfo {
                HStack(spacing: 8) {
                    Text("Change \(diff.currentIndex + 1)/\(diff.totalChanges)")
                        .font(.system(size: 11, design: .monospaced))
                    
                    if let change = diff.currentChange {
                        switch change.type {
                        case .addition:
                            Text("ADDED")
                                .font(.system(size: 10, weight: .bold))
                                .foregroundColor(.white)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(Color.green)
                                .cornerRadius(3)
                        case .deletion:
                            Text("DELETED: \"\(change.text.prefix(30))\(change.text.count > 30 ? "..." : "")\"")
                                .font(.system(size: 10))
                                .foregroundColor(.white)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(Color.red)
                                .cornerRadius(3)
                                .lineLimit(1)
                        case .unchanged:
                            EmptyView()
                        }
                    }
                    
                    Text("(n: next, p: prev, ESC: exit)")
                        .font(.system(size: 10))
                        .foregroundColor(.secondary)
                }
            } else {
                // Draft info (when not in comp mode)
                Text(draftInfo)
                    .font(.system(size: 11, design: .monospaced))
                    .foregroundColor(hasUnsavedChanges ? .orange : .secondary)
                
                if hasUnsavedChanges {
                    Text("*")
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.orange)
                }
                
                // BUGFIX #3: Branch indicator
                if let branch = branchInfo {
                    Text(branch)
                        .font(.system(size: 11, design: .monospaced))
                        .foregroundColor(.purple)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.purple.opacity(0.15))
                        .cornerRadius(4)
                }
            }
            
            Spacer()
            
            // Stats
            HStack(spacing: 12) {
                Text("\(stats.paragraphCount) ")
                Text("\(stats.sentenceCount) sentences")
                Text("\(stats.wordCount) words")
            }
            .font(.system(size: 11, design: .monospaced))
            .foregroundColor(.secondary)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(Color(NSColor.controlBackgroundColor))
    }
}

// MARK: - Sheets

struct FirstDraftSheet: View {
    @State private var draftName: String = ""
    let onSave: (String) -> Void
    let onCancel: () -> Void
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Save as First Draft")
                .font(.headline)
            
            Text("This will be the baseline for tracking your thought evolution.")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            
            TextField("Draft name (e.g., 'Initial thoughts')", text: $draftName)
                .textFieldStyle(.roundedBorder)
                .onSubmit {
                    if !draftName.isEmpty {
                        dismiss()
                        onSave(draftName)
                    }
                }
            
            HStack(spacing: 12) {
                Button("Cancel") {
                    dismiss()
                    onCancel()
                }
                .keyboardShortcut(.escape) // FIX: Add escape shortcut
                
                Button("Save") {
                    if !draftName.isEmpty {
                        dismiss()
                        onSave(draftName)
                    }
                }
                .keyboardShortcut(.return) // FIX: Add return shortcut
                .disabled(draftName.isEmpty)
            }
        }
        .padding(24)
        .frame(width: 450)
    }
}

struct PrintDraftSheet: View {
    @State private var draftName: String = ""
    @State private var comment: String = ""
    @FocusState private var focusedField: Field?
    let onSave: (String, String) -> Void
    @Environment(\.dismiss) var dismiss
    
    enum Field {
        case name
        case comment
    }
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Save Draft")
                .font(.headline)
            
            Text("Capture this evolution point with a name and comment.")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            
            TextField("Draft name", text: $draftName)
                .textFieldStyle(.roundedBorder)
                .focused($focusedField, equals: .name)
                .onSubmit {
                    // Move to comment field on Enter
                    focusedField = .comment
                }
            
            TextField("What changed in your thinking?", text: $comment)
                .textFieldStyle(.roundedBorder)
                .focused($focusedField, equals: .comment)
                .onSubmit {
                    // Save on Enter if both fields filled
                    if !draftName.isEmpty && !comment.isEmpty {
                        dismiss()
                        onSave(draftName, comment)
                    }
                }
            
            HStack(spacing: 12) {
                Button("Cancel") {
                    dismiss()
                }
                .keyboardShortcut(.escape)
                
                Button("Save") {
                    if !draftName.isEmpty && !comment.isEmpty {
                        dismiss()
                        onSave(draftName, comment)
                    }
                }
                .disabled(draftName.isEmpty || comment.isEmpty)
            }
        }
        .padding(24)
        .frame(width: 450)
        .onAppear {
            // Focus the name field on appear
            focusedField = .name
        }
    }
}


==================================================
FILE: Thesis/Document.swift
==================================================

import Foundation
import Combine

class Document: ObservableObject, Identifiable, Codable, Equatable {
    let id: UUID
    @Published var title: String
    @Published var currentContent: String
    @Published var drafts: [Draft]
    @Published var workingDraft: WorkingDraft?
    @Published var lastModified: Date
    
    // BUGFIX #3: Track the active branch parent for correct genealogy
    // When user restores a draft and saves, the new draft should parent to the restored draft
    @Published var activeBranchParentId: UUID?
    
    enum CodingKeys: String, CodingKey {
        case id, title, currentContent, drafts, workingDraft, lastModified, activeBranchParentId
    }
    
    init(title: String = "Untitled Thought") {
        self.id = UUID()
        self.title = title
        self.currentContent = ""
        self.drafts = []
        self.workingDraft = nil
        self.lastModified = Date()
        self.activeBranchParentId = nil
    }
    
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(UUID.self, forKey: .id)
        title = try container.decode(String.self, forKey: .title)
        currentContent = try container.decode(String.self, forKey: .currentContent)
        drafts = try container.decode([Draft].self, forKey: .drafts)
        workingDraft = try container.decodeIfPresent(WorkingDraft.self, forKey: .workingDraft)
        lastModified = try container.decode(Date.self, forKey: .lastModified)
        activeBranchParentId = try container.decodeIfPresent(UUID.self, forKey: .activeBranchParentId)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(title, forKey: .title)
        try container.encode(currentContent, forKey: .currentContent)
        try container.encode(drafts, forKey: .drafts)
        try container.encode(workingDraft, forKey: .workingDraft)
        try container.encode(lastModified, forKey: .lastModified)
        try container.encode(activeBranchParentId, forKey: .activeBranchParentId)
    }
    
    // MARK: - Equatable Conformance
    static func == (lhs: Document, rhs: Document) -> Bool {
        lhs.id == rhs.id
    }
    
    func saveFirstDraft(name: String) {
        let draft = Draft(
            name: name,
            content: currentContent,
            comment: "Initial capture",
            isFirstDraft: true
        )
        drafts.append(draft)
        workingDraft = nil
        lastModified = Date()
        // Set the active branch to this new draft
        activeBranchParentId = draft.id
    }
    
    func saveDraft(name: String, comment: String) {
        // BUGFIX #3: Use activeBranchParentId for correct genealogy
        // This ensures that if user restored Draft #2 and saves, the new draft
        // correctly parents to Draft #2, not just drafts.last
        let parentId = activeBranchParentId ?? drafts.last?.id
        
        let draft = Draft(
            name: name,
            content: currentContent,
            comment: comment,
            parentId: parentId
        )
        drafts.append(draft)
        workingDraft = nil
        lastModified = Date()
        
        // Update active branch to point to the new draft
        activeBranchParentId = draft.id
    }
    
    // BUGFIX #3: Non-destructive draft restoration with auto-snapshot
    func restoreDraft(_ draft: Draft) {
        // Safety Check: Is the current state dirty (has unsaved changes)?
        if hasUnsavedChanges {
            // Create an automatic snapshot before overwriting
            let snapshot = Draft(
                name: "Auto-Snapshot",
                content: currentContent,
                comment: "Snapshot taken before restoring '\(draft.name)'",
                parentId: latestDraft?.id
            )
            drafts.append(snapshot)
        }
        
        // Restore the content
        currentContent = draft.content
        
        // BUGFIX #3: Update the branch pointer to the restored draft
        // Next save will correctly parent to this draft, not the chronological last
        activeBranchParentId = draft.id
        
        // Update working draft
        updateWorkingDraft()
    }
    
    // FIX: Use async update to avoid "Publishing changes from within view updates" warning
    func updateWorkingDraft() {
        // Schedule the update for the next run loop to avoid SwiftUI state conflicts
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            self.workingDraft = WorkingDraft(content: self.currentContent)
            self.lastModified = Date()
        }
    }
    
    var hasUnsavedChanges: Bool {
        guard let lastDraft = drafts.last else {
            return !currentContent.isEmpty
        }
        return currentContent != lastDraft.content
    }
    
    var latestDraft: Draft? {
        return drafts.last
    }
    
    // MARK: - Branch Information (for UI display)
    
    /// Returns the draft that the current working content is branching from
    var currentBranchParent: Draft? {
        guard let parentId = activeBranchParentId else { return nil }
        return drafts.first { $0.id == parentId }
    }
    
    /// Returns true if the current content is branching from a non-latest draft
    var isBranching: Bool {
        guard let parentId = activeBranchParentId,
              let latestId = latestDraft?.id else {
            return false
        }
        return parentId != latestId
    }
}


==================================================
FILE: Thesis/EditCommand.swift
==================================================

import Foundation

struct UndoCommand {
    let beforeContent: String
    let afterContent: String
    let cursorBefore: Int
    let cursorAfter: Int
    
    func undo(in content: inout String) -> Int? {
        content = beforeContent
        return cursorBefore
    }
}

class UndoStack {
    private var commands: [UndoCommand] = []
    private let maxSize = 10
    
    func push(_ command: UndoCommand) {
        commands.append(command)
        if commands.count > maxSize {
            commands.removeFirst()
        }
    }
    
    func pop() -> UndoCommand? {
        guard !commands.isEmpty else { return nil }
        return commands.removeLast()
    }
    
    func clear() {
        commands.removeAll()
    }
    
    var canUndo: Bool {
        return !commands.isEmpty
    }
    
    var count: Int {
        return commands.count
    }
}


==================================================
FILE: Thesis/ContentView.swift
==================================================

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var documentManager: DocumentManager
    @State private var showingHistory = false
    
    var body: some View {
        HSplitView {
            // Sidebar - Document list
            DocumentSidebar(
                documents: documentManager.documents,
                selectedDocument: $documentManager.selectedDocument,
                onNewDocument: {
                    documentManager.createNewDocument()
                },
                onDeleteDocument: { doc in
                    documentManager.deleteDocument(doc)
                }
            )
            .frame(minWidth: 220, idealWidth: 260, maxWidth: 320)
            
            // Main editor area
            if let document = documentManager.selectedDocument {
                EditorContainer(
                    document: document,
                    showingHistory: $showingHistory,
                    onSave: {
                        documentManager.saveDocuments()
                    }
                )
            } else {
                EmptyStateView(
                    onNewDocument: {
                        documentManager.createNewDocument()
                    }
                )
            }
        }
        // FIX: Updated onChange syntax for macOS 14+
        .onChange(of: documentManager.selectedDocument) {
            documentManager.saveDocuments()
        }
    }
}

// MARK: - Document Sidebar

struct DocumentSidebar: View {
    let documents: [Document]
    @Binding var selectedDocument: Document?
    let onNewDocument: () -> Void
    let onDeleteDocument: (Document) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack {
                Text("Thoughts")
                    .font(.headline)
                Spacer()
                Button(action: onNewDocument) {
                    Image(systemName: "plus")
                }
                .buttonStyle(.borderless)
            }
            .padding()
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            // Document list
            List(documents) { doc in
                DocumentListItem(
                    document: doc,
                    isSelected: selectedDocument?.id == doc.id
                )
                .contentShape(Rectangle())
                .onTapGesture {
                    selectedDocument = doc
                }
                .contextMenu {
                    Button("Delete", role: .destructive) {
                        onDeleteDocument(doc)
                    }
                }
            }
            .listStyle(.sidebar)
        }
    }
}

struct DocumentListItem: View {
    @ObservedObject var document: Document
    let isSelected: Bool
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(document.title)
                    .font(.system(size: 13, weight: isSelected ? .semibold : .regular))
                
                if document.hasUnsavedChanges {
                    Circle()
                        .fill(Color.orange)
                        .frame(width: 6, height: 6)
                }
            }
            
            HStack {
                if let latest = document.latestDraft {
                    Text(latest.name)
                        .font(.system(size: 11))
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                } else {
                    Text("No draft")
                        .font(.system(size: 11))
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Text(document.lastModified, style: .relative)
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 4)
    }
}

// MARK: - Editor Container

struct EditorContainer: View {
    @ObservedObject var document: Document
    @Binding var showingHistory: Bool
    let onSave: () -> Void
    
    var body: some View {
        VStack(spacing: 0) {
            // Title bar
            HStack {
                TextField("Thought title", text: $document.title)
                    .textFieldStyle(.plain)
                    .font(.title2)
                    .padding()
                
                Spacer()
                
                Button(action: {
                    showingHistory.toggle()
                }) {
                    Label(showingHistory ? "Hide History" : "Show History",
                          systemImage: showingHistory ? "clock.fill" : "clock")
                }
                .buttonStyle(.borderless)
                .padding()
            }
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            // Editor with optional history
            HSplitView {
                // Main editor
                ModalEditor(document: .constant(document))
                    .frame(minWidth: 500)
                
                // History sidebar (when visible)
                if showingHistory {
                    DraftHistoryView(
                        document: document,
                        onRestore: { draft in
                            document.restoreDraft(draft)
                            onSave()
                        },
                        onClose: {
                            showingHistory = false
                        }
                    )
                    .frame(minWidth: 280, idealWidth: 340, maxWidth: 400)
                }
            }
        }
    }
}

// MARK: - Empty State

struct EmptyStateView: View {
    let onNewDocument: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "doc.text")
                .font(.system(size: 64))
                .foregroundColor(.secondary)
            
            Text("No Thought Selected")
                .font(.title2)
                .foregroundColor(.secondary)
            
            Text("Create a new thought or select one from the sidebar")
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            
            Button(action: onNewDocument) {
                Label("New Thought", systemImage: "plus.circle.fill")
                    .font(.headline)
            }
            .buttonStyle(.borderedProminent)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// MARK: - Preview

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(DocumentManager())
    }
}


==================================================
FILE: Thesis/DiffGenerator.swift
==================================================

import Foundation

struct DiffChange: Identifiable {
    let id = UUID()
    let type: ChangeType
    let range: NSRange      // Range in the NEW text (for additions/unchanged) or OLD text (for deletions)
    let text: String
    let displayRange: NSRange?  // Where to show indicator in current buffer (for deletions)
    
    enum ChangeType {
        case addition
        case deletion
        case unchanged
    }
    
    init(type: ChangeType, range: NSRange, text: String, displayRange: NSRange? = nil) {
        self.type = type
        self.range = range
        self.text = text
        self.displayRange = displayRange
    }
}

class DiffGenerator {
    
    /// Generate a diff that can be visualized in the current (new) text buffer
    /// - Additions: highlighted in green at their position in new text
    /// - Deletions: marked with red indicator at the position where they were removed
    static func generateDiff(from oldText: String, to newText: String) -> [DiffChange] {
        var changes: [DiffChange] = []
        
        let oldSentences = TextAnalyzer.getSentences(in: oldText)
        let newSentences = TextAnalyzer.getSentences(in: newText)
        
        // Create maps for quick lookup
        let oldSentenceSet = Set(oldSentences.map { $0.text })
        let newSentenceSet = Set(newSentences.map { $0.text })
        
        // Track positions in new text
        var currentLocation = 0
        
        // Process new sentences - mark additions and unchanged
        for newSentence in newSentences {
            let text = newSentence.text
            let range = NSRange(location: currentLocation, length: text.count)
            
            if oldSentenceSet.contains(text) {
                changes.append(DiffChange(
                    type: .unchanged,
                    range: range,
                    text: text
                ))
            } else {
                changes.append(DiffChange(
                    type: .addition,
                    range: range,
                    text: text
                ))
            }
            
            currentLocation += text.count
        }
        
        // Find deletions and calculate where they should be indicated
        // We'll show deletion markers at the position of the nearest remaining sentence
        for (index, oldSentence) in oldSentences.enumerated() {
            if !newSentenceSet.contains(oldSentence.text) {
                // Find where this deletion should be indicated in the new text
                // Look for the next sentence that still exists
                var displayLocation = 0
                
                // Find a nearby sentence that exists in both to anchor the deletion indicator
                for i in (0..<index).reversed() {
                    if newSentenceSet.contains(oldSentences[i].text) {
                        // Find this sentence in new text
                        if let match = newSentences.first(where: { $0.text == oldSentences[i].text }) {
                            displayLocation = match.range.location + match.range.length
                            break
                        }
                    }
                }
                
                changes.append(DiffChange(
                    type: .deletion,
                    range: oldSentence.range,  // Original range in old text
                    text: oldSentence.text,
                    displayRange: NSRange(location: displayLocation, length: 0)  // Where to show in new text
                ))
            }
        }
        
        // Sort by display position (use range.location for additions, displayRange for deletions)
        changes.sort { lhs, rhs in
            let lhsLoc = lhs.type == .deletion ? (lhs.displayRange?.location ?? 0) : lhs.range.location
            let rhsLoc = rhs.type == .deletion ? (rhs.displayRange?.location ?? 0) : rhs.range.location
            return lhsLoc < rhsLoc
        }
        
        return changes
    }
    
    static func getChangeIndices(in diff: [DiffChange]) -> [Int] {
        return diff.enumerated()
            .filter { $0.element.type != .unchanged }
            .map { $0.offset }
    }
    
    static func findNextChange(from currentIndex: Int, in diff: [DiffChange]) -> Int? {
        let changeIndices = getChangeIndices(in: diff)
        return changeIndices.first { $0 > currentIndex }
    }
    
    static func findPreviousChange(from currentIndex: Int, in diff: [DiffChange]) -> Int? {
        let changeIndices = getChangeIndices(in: diff)
        return changeIndices.last { $0 < currentIndex }
    }
}


==================================================
FILE: Thesis/EditorMode.swift
==================================================

import SwiftUI

enum EditorMode: Equatable {
    case freeText        // Initial writing mode - full freedom
    case edit            // Navigation and commands
    case insert(InsertContext)  // Constrained insertion
    case command(String) // Command entry (:comp, :print)
    case comp            // Compare/diff view
    
    var displayName: String {
        switch self {
        case .freeText: return "FREE TEXT"
        case .edit: return "EDIT"
        case .insert: return "INSERT"
        case .command: return "COMMAND"
        case .comp: return "COMPARE"
        }
    }
    
    var borderColor: Color {
        switch self {
        case .freeText: return .green
        case .edit: return .blue
        case .insert: return .green
        case .command: return .purple
        case .comp: return .orange
        }
    }
    
    static func == (lhs: EditorMode, rhs: EditorMode) -> Bool {
        switch (lhs, rhs) {
        case (.freeText, .freeText): return true
        case (.edit, .edit): return true
        case (.insert, .insert): return true
        case (.command, .command): return true
        case (.comp, .comp): return true
        default: return false
        }
    }
}

// MARK: - Insert Context

enum InsertContext {
    case word           // Exit on: space
    case sentence       // Exit on: . ! ?
    case paragraph      // Exit on: double newline
    
    var exitTriggers: [String] {
        switch self {
        case .word: return [" "]
        case .sentence: return [".", "!", "?"]
        case .paragraph: return ["\n\n"]
        }
    }
}

