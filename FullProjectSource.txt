THESIS — Complete Source Code (v2)
==================================
16 files, 4,397 lines

==================================================
FILE: Thesis/EditorMode.swift
==================================================

// EditorMode.swift — Thesis
// Modal states, verb-object grammar, insert contexts

import SwiftUI

enum EditorMode: Equatable {
    case freeText
    case normal
    case insert(InsertContext)
    case visual(VisualGranularity)      // Now tracks selection granularity
    case command(String)
    case comp
    
    var displayName: String {
        switch self {
        case .freeText:            return "FREE TEXT"
        case .normal:              return "NORMAL"
        case .insert(let c):       return "INSERT (\(c.displayName))"
        case .visual(let g):       return "VISUAL (\(g.rawValue))"
        case .command:             return "COMMAND"
        case .comp:                return "COMPARE"
        }
    }
    
    var borderColor: Color {
        switch self {
        case .freeText:  return .green
        case .normal:    return .blue
        case .insert:    return .green
        case .visual:    return .yellow
        case .command:   return .purple
        case .comp:      return .orange
        }
    }
    
    var statusColor: Color { borderColor }
    
    static func == (lhs: EditorMode, rhs: EditorMode) -> Bool {
        switch (lhs, rhs) {
        case (.freeText, .freeText), (.normal, .normal), (.comp, .comp): return true
        case (.insert(let a), .insert(let b)):   return a == b
        case (.visual(let a), .visual(let b)):   return a == b
        case (.command(let a), .command(let b)):  return a == b
        default: return false
        }
    }
}

// MARK: - Visual Mode Granularity

/// Controls what unit visual selection snaps to
enum VisualGranularity: String, Equatable {
    case character = "char"    // Free-form (default)
    case word      = "word"    // Snap to word boundaries
    case sentence  = "sent"    // Snap to sentence boundaries
    case paragraph = "para"    // Snap to paragraph boundaries
}

// MARK: - Insert Context

enum InsertContext: Equatable {
    case word
    case clause
    case sentence
    case paragraph
    case line
    case freeform      // No auto-exit (for 'i' insert at cursor)
    
    var displayName: String {
        switch self {
        case .word:      return "word"
        case .clause:    return "clause"
        case .sentence:  return "sentence"
        case .paragraph: return "paragraph"
        case .line:      return "line"
        case .freeform:  return "free"
        }
    }
    
    var autoExitCharacters: [Character] {
        switch self {
        case .word:      return [" "]
        case .clause:    return [",", ";", ":"]
        case .sentence:  return [".", "!", "?"]
        case .paragraph: return []
        case .line:      return ["\n"]
        case .freeform:  return []
        }
    }
    
    var exitsOnDoubleNewline: Bool { self == .paragraph }
}

// MARK: - Pending Verb

struct PendingVerb: Equatable {
    let verb: EditVerb
    let timestamp: Date
    
    init(_ verb: EditVerb) {
        self.verb = verb
        self.timestamp = Date()
    }
}

// MARK: - Edit Verb

enum EditVerb: String, Equatable {
    case delete  = "d"
    case change  = "c"
    case refine  = "r"
    case yank    = "y"
    case markup  = "m"
    case move    = "x"      // Move sentence/paragraph to a target
    
    var displayName: String {
        switch self {
        case .delete: return "DELETE"
        case .change: return "CHANGE"
        case .refine: return "REFINE"
        case .yank:   return "YANK"
        case .markup: return "MARKUP"
        case .move:   return "MOVE"
        }
    }
    
    var helpItems: [(key: String, description: String)] {
        switch self {
        case .delete:
            return [
                ("w", "delete word"),
                ("b", "delete word backward"),
                ("c", "delete clause"),
                ("s", "delete sentence"),
                ("p", "delete paragraph"),
            ]
        case .change:
            return [
                ("w", "change word"),
                ("c", "change clause"),
                ("s", "change sentence"),
                ("p", "change paragraph"),
            ]
        case .refine:
            return [
                ("w", "refine word"),
                ("c", "refine clause"),
                ("s", "refine sentence"),
                ("p", "refine paragraph"),
            ]
        case .yank:
            return [
                ("w", "yank word"),
                ("c", "yank clause"),
                ("s", "yank sentence"),
                ("p", "yank paragraph"),
            ]
        case .markup:
            return [
                ("w", "annotate word"),
                ("c", "annotate clause"),
                ("s", "annotate sentence"),
                ("p", "annotate paragraph"),
            ]
        case .move:
            return [
                ("s", "move sentence (then j/k to place, Enter to confirm)"),
                ("p", "move paragraph (then j/k to place, Enter to confirm)"),
            ]
        }
    }
}

// MARK: - Edit Object

enum EditObject: String {
    case word      = "w"
    case wordBack  = "b"
    case clause    = "c"
    case sentence  = "s"
    case paragraph = "p"
}

// MARK: - Last Command (for repeat with '.')

struct LastCommand: Equatable {
    let verb: EditVerb
    let object: EditObject?
    let insertedText: String?
    
    static func == (lhs: LastCommand, rhs: LastCommand) -> Bool {
        lhs.verb == rhs.verb && lhs.object == rhs.object
    }
}

==================================================
FILE: Thesis/SemanticChange.swift
==================================================

// SemanticChange.swift — Thesis
// Semantic change tracking: WHY edits happened, not just WHAT changed

import Foundation

// MARK: - Text Unit

struct TextUnit {
    let range: NSRange
    let text: String
    
    var isEmpty: Bool { text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
    var endLocation: Int { range.location + range.length }
}

enum TextUnitType: String, Codable {
    case word
    case clause
    case sentence
    case paragraph
    case section
}

// MARK: - Semantic Change Type

enum SemanticChangeType: String, Codable, Equatable, CaseIterable {
    case added
    case deleted
    case replaced
    case refined
    case moved
    
    var displayName: String {
        switch self {
        case .added:    return "Added"
        case .deleted:  return "Deleted"
        case .replaced: return "Replaced"
        case .refined:  return "Refined"
        case .moved:    return "Moved"
        }
    }
    
    var icon: String {
        switch self {
        case .added:    return "plus.circle.fill"
        case .deleted:  return "minus.circle.fill"
        case .replaced: return "arrow.triangle.2.circlepath"
        case .refined:  return "sparkles"
        case .moved:    return "arrow.up.arrow.down"
        }
    }
    
    var color: String {
        switch self {
        case .added:    return "green"
        case .deleted:  return "red"
        case .replaced: return "orange"
        case .refined:  return "blue"
        case .moved:    return "purple"
        }
    }
}

// MARK: - Semantic Change Record

struct SemanticChange: Identifiable, Codable, Equatable {
    let id: UUID
    let type: SemanticChangeType
    let unitType: TextUnitType
    let beforeText: String?
    let afterText: String?
    let position: Int
    let context: String
    let timestamp: Date
    
    init(
        type: SemanticChangeType,
        unitType: TextUnitType,
        beforeText: String? = nil,
        afterText: String? = nil,
        position: Int,
        context: String,
        timestamp: Date = Date()
    ) {
        self.id = UUID()
        self.type = type
        self.unitType = unitType
        self.beforeText = beforeText
        self.afterText = afterText
        self.position = position
        self.context = context
        self.timestamp = timestamp
    }
    
    var displayText: String {
        switch type {
        case .added:
            return afterText.map { "\"\(String($0.prefix(60)))\($0.count > 60 ? "…" : "")\"" } ?? ""
        case .deleted:
            return beforeText.map { "\"\(String($0.prefix(60)))\($0.count > 60 ? "…" : "")\"" } ?? ""
        case .replaced, .refined:
            let before = beforeText.map { String($0.prefix(30)) } ?? ""
            let after = afterText.map { String($0.prefix(30)) } ?? ""
            return "\"\(before)\" → \"\(after)\""
        case .moved:
            return context
        }
    }
    
    var summary: String { "\(type.displayName) \(unitType.rawValue)" }
    
    var isDarling: Bool { type == .deleted || type == .replaced }
    
    var lostText: String? {
        guard isDarling else { return nil }
        return beforeText
    }
}

// MARK: - Pending Change Tracker (improved: tracks insert start position)

class PendingChangeTracker {
    private(set) var change: SemanticChange?
    private(set) var insertStartPosition: Int?
    
    var hasPending: Bool { change != nil }
    
    func startChange(
        type: SemanticChangeType,
        unitType: TextUnitType,
        beforeText: String?,
        position: Int,
        context: String
    ) {
        change = SemanticChange(
            type: type,
            unitType: unitType,
            beforeText: beforeText,
            position: position,
            context: context
        )
        insertStartPosition = position
    }
    
    /// Complete the pending change by extracting the actual inserted text
    /// from the document content using the tracked start position and current cursor.
    func completeChange(currentContent: String, cursorPosition: Int) -> SemanticChange? {
        guard let current = change else { return nil }
        let startPos = insertStartPosition ?? current.position
        let nsContent = currentContent as NSString
        
        // Extract the actual text that was inserted
        let safeStart = max(0, min(startPos, nsContent.length))
        let safeEnd = max(safeStart, min(cursorPosition, nsContent.length))
        let insertedLength = safeEnd - safeStart
        
        var afterText = ""
        if insertedLength > 0 {
            let range = NSRange(location: safeStart, length: insertedLength)
            afterText = nsContent.substring(with: range)
        }
        
        // For replace/refine, the "after" text is the new content
        // For add, the "after" text is what was typed
        let completed = SemanticChange(
            type: current.type,
            unitType: current.unitType,
            beforeText: current.beforeText,
            afterText: afterText.isEmpty ? nil : afterText,
            position: current.position,
            context: current.context,
            timestamp: current.timestamp
        )
        
        change = nil
        insertStartPosition = nil
        return completed
    }
    
    /// Legacy completion (when we already know the after text)
    func completeChange(afterText: String) -> SemanticChange? {
        guard let current = change else { return nil }
        let completed = SemanticChange(
            type: current.type,
            unitType: current.unitType,
            beforeText: current.beforeText,
            afterText: afterText.isEmpty ? nil : afterText,
            position: current.position,
            context: current.context,
            timestamp: current.timestamp
        )
        change = nil
        insertStartPosition = nil
        return completed
    }
    
    func cancel() {
        change = nil
        insertStartPosition = nil
    }
}

// MARK: - Change Summary

struct ChangeSummary {
    let changes: [SemanticChange]
    
    var text: String {
        var counts: [SemanticChangeType: Int] = [:]
        for change in changes { counts[change.type, default: 0] += 1 }
        let parts = counts.sorted { $0.key.displayName < $1.key.displayName }
            .map { "\($0.value) \($0.key.displayName.lowercased())" }
        return parts.isEmpty ? "No changes" : parts.joined(separator: ", ")
    }
    
    var breakdown: [(type: SemanticChangeType, count: Int)] {
        var counts: [SemanticChangeType: Int] = [:]
        for change in changes { counts[change.type, default: 0] += 1 }
        return counts.map { (type: $0.key, count: $0.value) }
            .sorted { $0.type.displayName < $1.type.displayName }
    }
}

==================================================
FILE: Thesis/TextAnalyzer.swift
==================================================

// TextAnalyzer.swift — Thesis
// NLP-powered text boundary detection with caching and invalidation
// Uses Apple NaturalLanguage framework for word, clause, sentence, paragraph parsing

import Foundation
import NaturalLanguage

// MARK: - Cached Text Analyzer (instance per editor, invalidated per edit)

class CachedTextAnalyzer {
    private var cachedText: String = ""
    private var _sentences: [TextUnit]?
    private var _clauses: [TextUnit]?
    private var _paragraphs: [TextUnit]?
    private var _words: [TextUnit]?
    private var _stats: TextAnalyzer.Stats?
    
    func invalidate() {
        _sentences = nil
        _clauses = nil
        _paragraphs = nil
        _words = nil
        _stats = nil
    }
    
    private func ensureText(_ text: String) {
        if text != cachedText {
            invalidate()
            cachedText = text
        }
    }
    
    func sentences(in text: String) -> [TextUnit] {
        ensureText(text)
        if let c = _sentences { return c }
        let r = TextAnalyzer.getSentences(in: text)
        _sentences = r
        return r
    }
    
    func clauses(in text: String) -> [TextUnit] {
        ensureText(text)
        if let c = _clauses { return c }
        let r = TextAnalyzer.getClauses(in: text)
        _clauses = r
        return r
    }
    
    func paragraphs(in text: String) -> [TextUnit] {
        ensureText(text)
        if let c = _paragraphs { return c }
        let r = TextAnalyzer.getParagraphs(in: text)
        _paragraphs = r
        return r
    }
    
    func words(in text: String) -> [TextUnit] {
        ensureText(text)
        if let c = _words { return c }
        let r = TextAnalyzer.getWords(in: text)
        _words = r
        return r
    }
    
    func stats(for text: String) -> TextAnalyzer.Stats {
        ensureText(text)
        if let c = _stats { return c }
        let r = TextAnalyzer.Stats(
            paragraphCount: paragraphs(in: text).count,
            sentenceCount: sentences(in: text).count,
            wordCount: words(in: text).count
        )
        _stats = r
        return r
    }
    
    // Convenience methods mirroring static API
    
    func sentenceAt(_ pos: Int, in text: String) -> TextUnit? {
        sentences(in: text).first { NSLocationInRange(pos, $0.range) }
    }
    
    func clauseAt(_ pos: Int, in text: String) -> TextUnit? {
        clauses(in: text).first { NSLocationInRange(pos, $0.range) }
    }
    
    func paragraphAt(_ pos: Int, in text: String) -> TextUnit? {
        paragraphs(in: text).first { NSLocationInRange(pos, $0.range) }
    }
    
    func wordAt(_ pos: Int, in text: String) -> TextUnit? {
        let ws = words(in: text)
        return ws.first(where: { NSLocationInRange(pos, $0.range) })
            ?? ws.first(where: { $0.range.location >= pos })
    }
    
    func nextSentence(from pos: Int, in text: String) -> TextUnit? {
        sentences(in: text).first { $0.range.location > pos }
    }
    
    func prevSentence(from pos: Int, in text: String) -> TextUnit? {
        sentences(in: text).last { $0.range.location < pos }
    }
    
    func nextWord(from pos: Int, in text: String) -> TextUnit? {
        words(in: text).first(where: {
            $0.range.location > pos &&
            !$0.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        })
    }
    
    func prevWord(from pos: Int, in text: String) -> TextUnit? {
        let ws = words(in: text)
        let currentStart = ws.first(where: {
            NSLocationInRange(pos, $0.range) || $0.range.location == pos
        })?.range.location ?? pos
        return ws.last(where: {
            $0.range.location < currentStart &&
            !$0.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        })
    }
}

// MARK: - TextAnalyzer (static methods)

class TextAnalyzer {
    
    // MARK: - Sentence Detection
    
    static func getSentences(in text: String) -> [TextUnit] {
        guard !text.isEmpty else { return [] }
        var sentences: [TextUnit] = []
        let nsText = text as NSString
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        tagger.enumerateTags(
            in: text.startIndex..<text.endIndex,
            unit: .sentence,
            scheme: .lexicalClass
        ) { _, range in
            let nsRange = NSRange(range, in: text)
            sentences.append(TextUnit(range: nsRange, text: nsText.substring(with: nsRange)))
            return true
        }
        return sentences
    }
    
    static func getSentenceAt(position: Int, in text: String) -> TextUnit? {
        getSentences(in: text).first { NSLocationInRange(position, $0.range) }
    }
    
    static func getNextSentence(from position: Int, in text: String) -> TextUnit? {
        getSentences(in: text).first { $0.range.location > position }
    }
    
    static func getPreviousSentence(from position: Int, in text: String) -> TextUnit? {
        getSentences(in: text).last { $0.range.location < position }
    }
    
    // MARK: - Clause Detection
    
    static func getClauses(in text: String) -> [TextUnit] {
        guard !text.isEmpty else { return [] }
        var clauses: [TextUnit] = []
        let sentences = getSentences(in: text)
        let nsText = text as NSString
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        
        for sentence in sentences {
            tagger.string = sentence.text
            var lastBoundary = 0
            
            tagger.enumerateTags(
                in: sentence.text.startIndex..<sentence.text.endIndex,
                unit: .word,
                scheme: .lexicalClass
            ) { tag, range in
                let wordRange = NSRange(range, in: sentence.text)
                let word = (sentence.text as NSString).substring(with: wordRange).lowercased()
                let isBoundaryPunct = (tag == .punctuation && (word == "," || word == ";" || word == ":"))
                let isConjunction = (tag == .conjunction)
                
                if isBoundaryPunct || isConjunction {
                    let length = wordRange.location - lastBoundary
                    if length > 0 {
                        let clauseRange = NSRange(location: sentence.range.location + lastBoundary, length: length)
                        clauses.append(TextUnit(range: clauseRange, text: nsText.substring(with: clauseRange)))
                    }
                    lastBoundary = wordRange.location
                }
                return true
            }
            
            let finalLength = sentence.range.length - lastBoundary
            if finalLength > 0 {
                let finalRange = NSRange(location: sentence.range.location + lastBoundary, length: finalLength)
                clauses.append(TextUnit(range: finalRange, text: nsText.substring(with: finalRange)))
            }
        }
        return clauses
    }
    
    static func getClauseAt(position: Int, in text: String) -> TextUnit? {
        getClauses(in: text).first { NSLocationInRange(position, $0.range) }
    }
    
    // MARK: - Paragraph Detection
    
    static func getParagraphs(in text: String) -> [TextUnit] {
        guard !text.isEmpty else { return [] }
        var paragraphs: [TextUnit] = []
        let nsText = text as NSString
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        tagger.enumerateTags(
            in: text.startIndex..<text.endIndex,
            unit: .paragraph,
            scheme: .lexicalClass
        ) { _, range in
            let nsRange = NSRange(range, in: text)
            let paraText = nsText.substring(with: nsRange)
            if !paraText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                paragraphs.append(TextUnit(range: nsRange, text: paraText))
            }
            return true
        }
        return paragraphs
    }
    
    static func getParagraphAt(position: Int, in text: String) -> TextUnit? {
        getParagraphs(in: text).first { NSLocationInRange(position, $0.range) }
    }
    
    // MARK: - Word Detection
    
    static func getWords(in text: String) -> [TextUnit] {
        guard !text.isEmpty else { return [] }
        var words: [TextUnit] = []
        let nsText = text as NSString
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        tagger.enumerateTags(
            in: text.startIndex..<text.endIndex,
            unit: .word,
            scheme: .lexicalClass
        ) { _, range in
            let nsRange = NSRange(range, in: text)
            words.append(TextUnit(range: nsRange, text: nsText.substring(with: nsRange)))
            return true
        }
        return words
    }
    
    static func getWordAt(position: Int, in text: String) -> TextUnit? {
        let words = getWords(in: text)
        return words.first(where: { NSLocationInRange(position, $0.range) })
            ?? words.first(where: { $0.range.location >= position })
    }
    
    // MARK: - Line Navigation
    
    static func getNextLineStart(from position: Int, in text: String) -> Int {
        let nsText = text as NSString
        guard position < nsText.length else { return nsText.length }
        let range = NSRange(location: position, length: nsText.length - position)
        let next = nsText.range(of: "\n", options: [], range: range)
        return next.location != NSNotFound ? min(next.location + 1, nsText.length) : nsText.length
    }
    
    static func getPreviousLineStart(from position: Int, in text: String) -> Int {
        let nsText = text as NSString
        guard position > 0 else { return 0 }
        let range = NSRange(location: 0, length: min(position, nsText.length))
        let prev = nsText.range(of: "\n", options: .backwards, range: range)
        if prev.location != NSNotFound {
            if prev.location == position - 1 {
                let sub = NSRange(location: 0, length: prev.location)
                let p2 = nsText.range(of: "\n", options: .backwards, range: sub)
                return p2.location != NSNotFound ? p2.location + 1 : 0
            }
            return prev.location + 1
        }
        return 0
    }
    
    // MARK: - Helpers
    
    static func getRestOfSentence(from position: Int, in text: String) -> TextUnit? {
        guard let sentence = getSentenceAt(position: position, in: text) else { return nil }
        let restEnd = sentence.endLocation
        guard restEnd > position else { return nil }
        let restRange = NSRange(location: position, length: restEnd - position)
        let nsText = text as NSString
        guard restRange.location + restRange.length <= nsText.length else { return nil }
        return TextUnit(range: restRange, text: nsText.substring(with: restRange))
    }
    
    static func expandToTrailingSpace(_ range: NSRange, in text: String) -> NSRange {
        let nsText = text as NSString
        var expanded = range
        var endPos = expanded.location + expanded.length
        while endPos < nsText.length {
            let c = nsText.substring(with: NSRange(location: endPos, length: 1))
            if c == " " || c == "\t" { expanded.length += 1; endPos += 1 }
            else { break }
        }
        return expanded
    }
    
    static func expandToLeadingSpace(_ range: NSRange, in text: String) -> NSRange {
        let nsText = text as NSString
        var expanded = range
        while expanded.location > 0 {
            let c = nsText.substring(with: NSRange(location: expanded.location - 1, length: 1))
            if c == " " || c == "\t" { expanded.location -= 1; expanded.length += 1 }
            else { break }
        }
        return expanded
    }
    
    // MARK: - Safe Range Utilities
    
    static func safeRange(_ range: NSRange, in length: Int) -> NSRange {
        guard length > 0 else { return NSRange(location: 0, length: 0) }
        let loc = max(0, min(range.location, length))
        let len = max(0, min(range.length, length - loc))
        return NSRange(location: loc, length: len)
    }
    
    static func safePosition(_ position: Int, in text: String) -> Int {
        max(0, min(position, (text as NSString).length))
    }
    
    // MARK: - Statistics
    
    struct Stats {
        let paragraphCount: Int
        let sentenceCount: Int
        let wordCount: Int
    }
    
    static func computeStats(for text: String) -> Stats {
        Stats(
            paragraphCount: getParagraphs(in: text).count,
            sentenceCount: getSentences(in: text).count,
            wordCount: getWords(in: text).count
        )
    }
}

==================================================
FILE: Thesis/UndoSystem.swift
==================================================

// UndoSystem.swift — Thesis
// Operation-based undo/redo that stays in sync with semantic change history

import Foundation

// MARK: - Undoable Operation Protocol

protocol UndoableOperation {
    var description: String { get }
    func undo(content: inout String) -> Int
    func redo(content: inout String) -> Int
    var semanticChange: SemanticChange? { get }
}

// MARK: - Delete Operation

struct DeleteOperation: UndoableOperation {
    let range: NSRange
    let deletedText: String
    let cursorBefore: Int
    let semanticChange: SemanticChange?
    
    var description: String { "Delete \"\(String(deletedText.prefix(30)))\"" }
    
    func undo(content: inout String) -> Int {
        let nsContent = content as NSString
        let location = min(range.location, nsContent.length)
        content = nsContent.replacingCharacters(
            in: NSRange(location: location, length: 0),
            with: deletedText
        )
        return cursorBefore
    }
    
    func redo(content: inout String) -> Int {
        let nsContent = content as NSString
        let safeRange = TextAnalyzer.safeRange(range, in: nsContent.length)
        content = nsContent.replacingCharacters(in: safeRange, with: "")
        return safeRange.location
    }
}

// MARK: - Insert Operation

struct InsertOperation: UndoableOperation {
    let position: Int
    let insertedText: String
    let semanticChange: SemanticChange?
    
    var description: String { "Insert \"\(String(insertedText.prefix(30)))\"" }
    
    func undo(content: inout String) -> Int {
        let nsContent = content as NSString
        let removeRange = NSRange(
            location: min(position, nsContent.length),
            length: min(insertedText.count, nsContent.length - min(position, nsContent.length))
        )
        content = nsContent.replacingCharacters(in: removeRange, with: "")
        return position
    }
    
    func redo(content: inout String) -> Int {
        let nsContent = content as NSString
        let location = min(position, nsContent.length)
        content = nsContent.replacingCharacters(
            in: NSRange(location: location, length: 0),
            with: insertedText
        )
        return location + insertedText.count
    }
}

// MARK: - Replace Operation

struct ReplaceOperation: UndoableOperation {
    let range: NSRange
    let oldText: String
    let newText: String
    let cursorBefore: Int
    let semanticChange: SemanticChange?
    
    var description: String { "Replace \"\(String(oldText.prefix(20)))\" → \"\(String(newText.prefix(20)))\"" }
    
    func undo(content: inout String) -> Int {
        let nsContent = content as NSString
        let location = min(range.location, nsContent.length)
        let replaceRange = NSRange(
            location: location,
            length: min(newText.count, nsContent.length - location)
        )
        content = nsContent.replacingCharacters(in: replaceRange, with: oldText)
        return cursorBefore
    }
    
    func redo(content: inout String) -> Int {
        let nsContent = content as NSString
        let location = min(range.location, nsContent.length)
        let replaceRange = NSRange(
            location: location,
            length: min(oldText.count, nsContent.length - location)
        )
        content = nsContent.replacingCharacters(in: replaceRange, with: newText)
        return location + newText.count
    }
}

// MARK: - Move Operation

struct MoveOperation: UndoableOperation {
    let sourceRange: NSRange
    let movedText: String
    let destinationPosition: Int
    let cursorBefore: Int
    let semanticChange: SemanticChange?
    
    var description: String { "Move \"\(String(movedText.prefix(30)))\"" }
    
    func undo(content: inout String) -> Int {
        // Remove from destination
        let nsContent1 = content as NSString
        let destRange: NSRange
        if destinationPosition <= sourceRange.location {
            destRange = NSRange(location: destinationPosition, length: movedText.count)
        } else {
            destRange = NSRange(location: destinationPosition - sourceRange.length, length: movedText.count)
        }
        let safeDestRange = TextAnalyzer.safeRange(destRange, in: nsContent1.length)
        content = nsContent1.replacingCharacters(in: safeDestRange, with: "")
        
        // Reinsert at source
        let nsContent2 = content as NSString
        let sourcePos = min(sourceRange.location, nsContent2.length)
        content = nsContent2.replacingCharacters(
            in: NSRange(location: sourcePos, length: 0),
            with: movedText
        )
        return cursorBefore
    }
    
    func redo(content: inout String) -> Int {
        // Remove from source
        let nsContent1 = content as NSString
        let safeSource = TextAnalyzer.safeRange(sourceRange, in: nsContent1.length)
        content = nsContent1.replacingCharacters(in: safeSource, with: "")
        
        // Insert at destination (adjusted)
        let nsContent2 = content as NSString
        let adjustedDest: Int
        if destinationPosition > sourceRange.location {
            adjustedDest = destinationPosition - sourceRange.length
        } else {
            adjustedDest = destinationPosition
        }
        let safeDest = min(adjustedDest, nsContent2.length)
        content = nsContent2.replacingCharacters(
            in: NSRange(location: safeDest, length: 0),
            with: movedText
        )
        return safeDest + movedText.count
    }
}

// MARK: - Undo Stack

class UndoStack: ObservableObject {
    private var undoHistory: [UndoableOperation] = []
    private var redoHistory: [UndoableOperation] = []
    private let maxSize = 200
    
    var canUndo: Bool { !undoHistory.isEmpty }
    var canRedo: Bool { !redoHistory.isEmpty }
    var count: Int { undoHistory.count }
    
    var undoPreview: String? { undoHistory.last?.description }
    var redoPreview: String? { redoHistory.last?.description }
    
    func push(_ operation: UndoableOperation) {
        undoHistory.append(operation)
        redoHistory.removeAll()
        if undoHistory.count > maxSize { undoHistory.removeFirst() }
    }
    
    func undo(content: inout String) -> (cursor: Int, change: SemanticChange?)? {
        guard let operation = undoHistory.popLast() else { return nil }
        let cursor = operation.undo(content: &content)
        redoHistory.append(operation)
        return (cursor, operation.semanticChange)
    }
    
    func redo(content: inout String) -> (cursor: Int, change: SemanticChange?)? {
        guard let operation = redoHistory.popLast() else { return nil }
        let cursor = operation.redo(content: &content)
        undoHistory.append(operation)
        return (cursor, operation.semanticChange)
    }
    
    func clear() {
        undoHistory.removeAll()
        redoHistory.removeAll()
    }
}

==================================================
FILE: Thesis/Annotation.swift
==================================================

// Annotation.swift — Thesis
// Positional annotations with categories, fuzzy anchor tracking, and navigation

import Foundation

// MARK: - Annotation Category

enum AnnotationCategory: String, Codable, CaseIterable, Equatable {
    case note       = "note"
    case todo       = "todo"
    case question   = "question"
    case research   = "research"
    case fix        = "fix"
    case idea       = "idea"
    
    var displayName: String {
        switch self {
        case .note:     return "Note"
        case .todo:     return "To Do"
        case .question: return "Question"
        case .research: return "Research"
        case .fix:      return "Fix"
        case .idea:     return "Idea"
        }
    }
    
    var icon: String {
        switch self {
        case .note:     return "note.text"
        case .todo:     return "checkmark.circle"
        case .question: return "questionmark.circle"
        case .research: return "magnifyingglass"
        case .fix:      return "wrench"
        case .idea:     return "lightbulb"
        }
    }
    
    var color: String {
        switch self {
        case .note:     return "purple"
        case .todo:     return "orange"
        case .question: return "blue"
        case .research: return "green"
        case .fix:      return "red"
        case .idea:     return "yellow"
        }
    }
}

// MARK: - Annotation

struct Annotation: Identifiable, Codable, Equatable {
    let id: UUID
    var text: String
    var anchorText: String
    var anchorPosition: Int
    var category: AnnotationCategory
    var resolved: Bool
    let createdAt: Date
    var updatedAt: Date
    
    init(
        text: String,
        anchorText: String,
        anchorPosition: Int,
        category: AnnotationCategory = .note
    ) {
        self.id = UUID()
        self.text = text
        self.anchorText = anchorText
        self.anchorPosition = anchorPosition
        self.category = category
        self.resolved = false
        self.createdAt = Date()
        self.updatedAt = Date()
    }
    
    /// Find the current range of this annotation's anchor text in the document.
    /// Uses progressive search: exact near original position → exact full doc → fuzzy.
    func currentRange(in content: String) -> NSRange? {
        let nsContent = content as NSString
        guard nsContent.length > 0, !anchorText.isEmpty else { return nil }
        
        // 1. Exact match near original position (fast path)
        let searchRadius = 500
        let searchStart = max(0, anchorPosition - searchRadius)
        let searchEnd = min(nsContent.length, anchorPosition + anchorText.count + searchRadius)
        if searchEnd > searchStart {
            let localRange = NSRange(location: searchStart, length: searchEnd - searchStart)
            let found = nsContent.range(of: anchorText, options: [], range: localRange)
            if found.location != NSNotFound { return found }
        }
        
        // 2. Exact match anywhere in document
        let fullRange = nsContent.range(of: anchorText)
        if fullRange.location != NSNotFound { return fullRange }
        
        // 3. Fuzzy match: try with first 30 characters (handles partial edits to anchor text)
        if anchorText.count > 30 {
            let prefix = String(anchorText.prefix(30))
            let prefixRange = nsContent.range(of: prefix)
            if prefixRange.location != NSNotFound {
                // Extend to a reasonable length
                let endPos = min(prefixRange.location + anchorText.count + 20, nsContent.length)
                return NSRange(location: prefixRange.location, length: endPos - prefixRange.location)
            }
        }
        
        // 4. Case-insensitive match
        let ciRange = nsContent.range(of: anchorText, options: .caseInsensitive)
        if ciRange.location != NSNotFound { return ciRange }
        
        return nil
    }
    
    /// Update the anchor position to match current document state
    mutating func updateAnchorPosition(in content: String) {
        if let range = currentRange(in: content) {
            anchorPosition = range.location
        }
    }
    
    var displayTimestamp: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: createdAt, relativeTo: Date())
    }
    
    var isStale: Bool {
        // An annotation is stale if created more than 30 days ago and unresolved
        !resolved && createdAt.timeIntervalSinceNow < -2_592_000
    }
}

==================================================
FILE: Thesis/Draft.swift
==================================================

// Draft.swift — Thesis
// Version snapshots (commits) and branch management

import Foundation

// MARK: - Draft (a committed snapshot)

struct Draft: Identifiable, Codable, Equatable {
    let id: UUID
    let name: String
    let content: String
    let timestamp: Date
    let comment: String
    let parentId: UUID?
    let secondParentId: UUID?    // Non-nil for merge commits
    let branchName: String
    let isFirstDraft: Bool
    let changes: [SemanticChange]
    
    init(
        name: String,
        content: String,
        comment: String = "",
        parentId: UUID? = nil,
        secondParentId: UUID? = nil,
        branchName: String = "main",
        isFirstDraft: Bool = false,
        changes: [SemanticChange] = []
    ) {
        self.id = UUID()
        self.name = name
        self.content = content
        self.timestamp = Date()
        self.comment = comment
        self.parentId = parentId
        self.secondParentId = secondParentId
        self.branchName = branchName
        self.isFirstDraft = isFirstDraft
        self.changes = changes
    }
    
    var displayTimestamp: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: timestamp)
    }
    
    var displayName: String {
        if isFirstDraft { return "First Draft: \(name)" }
        if isMergeCommit { return "Merge: \(name)" }
        return name
    }
    
    var isMergeCommit: Bool { secondParentId != nil }
    
    var changeSummary: String {
        guard !changes.isEmpty else {
            return isFirstDraft ? "Initial capture" : "No changes"
        }
        return ChangeSummary(changes: changes).text
    }
    
    var changeCount: Int { changes.count }
    
    var darlings: [String] {
        changes.compactMap { $0.lostText }.filter { !$0.isEmpty }
    }
}

// MARK: - Branch

struct Branch: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var headDraftId: UUID
    let createdAt: Date
    let branchPoint: UUID        // Draft where this branch diverged
    var description: String
    
    init(name: String, headDraftId: UUID, branchPoint: UUID, description: String = "") {
        self.id = UUID()
        self.name = name
        self.headDraftId = headDraftId
        self.createdAt = Date()
        self.branchPoint = branchPoint
        self.description = description
    }
}

// MARK: - Working Draft

struct WorkingDraft: Codable {
    var content: String
    var lastSaved: Date
    var pendingChanges: [SemanticChange]
    
    init(content: String, pendingChanges: [SemanticChange] = []) {
        self.content = content
        self.lastSaved = Date()
        self.pendingChanges = pendingChanges
    }
}

// MARK: - Merge Conflict

struct MergeConflict: Identifiable {
    let id = UUID()
    let position: Int
    let ourText: String
    let theirText: String
    let commonAncestorText: String?
    var resolution: MergeResolution = .unresolved
}

enum MergeResolution: Equatable {
    case unresolved
    case keepOurs
    case keepTheirs
    case combined(String)
}

// MARK: - Merge Result

struct MergeResult {
    let mergedContent: String
    let conflicts: [MergeConflict]
    let hasUnresolvedConflicts: Bool
    
    var isClean: Bool { conflicts.isEmpty }
}

==================================================
FILE: Thesis/Document.swift
==================================================

// Document.swift — Thesis
// Core document model: content, branches, version history, annotations

import Foundation
import Combine

class Document: ObservableObject, Identifiable, Codable, Equatable {
    let id: UUID
    @Published var title: String
    @Published var currentContent: String
    @Published var drafts: [Draft]
    @Published var branches: [Branch]
    @Published var activeBranchName: String
    @Published var workingDraft: WorkingDraft?
    @Published var lastModified: Date
    @Published var annotations: [Annotation]
    @Published var sessionChanges: [SemanticChange]
    @Published var yankRegister: String?
    
    // Debounce timer for working draft auto-save
    private var workingDraftTimer: Timer?
    
    enum CodingKeys: String, CodingKey {
        case id, title, currentContent, drafts, branches, activeBranchName
        case workingDraft, lastModified, annotations, sessionChanges
    }
    
    init(title: String = "Untitled Thought") {
        self.id = UUID()
        self.title = title
        self.currentContent = ""
        self.drafts = []
        self.branches = []
        self.activeBranchName = "main"
        self.workingDraft = nil
        self.lastModified = Date()
        self.annotations = []
        self.sessionChanges = []
        self.yankRegister = nil
    }
    
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(UUID.self, forKey: .id)
        title = try container.decode(String.self, forKey: .title)
        currentContent = try container.decode(String.self, forKey: .currentContent)
        drafts = try container.decode([Draft].self, forKey: .drafts)
        branches = try container.decodeIfPresent([Branch].self, forKey: .branches) ?? []
        activeBranchName = try container.decodeIfPresent(String.self, forKey: .activeBranchName) ?? "main"
        workingDraft = try container.decodeIfPresent(WorkingDraft.self, forKey: .workingDraft)
        lastModified = try container.decode(Date.self, forKey: .lastModified)
        annotations = try container.decodeIfPresent([Annotation].self, forKey: .annotations) ?? []
        sessionChanges = try container.decodeIfPresent([SemanticChange].self, forKey: .sessionChanges) ?? []
        yankRegister = nil
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(title, forKey: .title)
        try container.encode(currentContent, forKey: .currentContent)
        try container.encode(drafts, forKey: .drafts)
        try container.encode(branches, forKey: .branches)
        try container.encode(activeBranchName, forKey: .activeBranchName)
        try container.encode(workingDraft, forKey: .workingDraft)
        try container.encode(lastModified, forKey: .lastModified)
        try container.encode(annotations, forKey: .annotations)
        try container.encode(sessionChanges, forKey: .sessionChanges)
    }
    
    static func == (lhs: Document, rhs: Document) -> Bool { lhs.id == rhs.id }
    
    // MARK: - Draft Management
    
    func saveFirstDraft(name: String) {
        let autoName = name.isEmpty ? "Draft — \(formattedNow)" : name
        let draft = Draft(
            name: autoName,
            content: currentContent,
            comment: "Initial capture",
            branchName: "main",
            isFirstDraft: true
        )
        drafts.append(draft)
        
        // Create the main branch
        let mainBranch = Branch(name: "main", headDraftId: draft.id, branchPoint: draft.id)
        branches.append(mainBranch)
        activeBranchName = "main"
        
        workingDraft = nil
        sessionChanges = []
        lastModified = Date()
    }
    
    func saveDraft(name: String, comment: String) {
        let parentId = currentBranchHead?.id ?? drafts.last?.id
        let draft = Draft(
            name: name,
            content: currentContent,
            comment: comment,
            parentId: parentId,
            branchName: activeBranchName,
            changes: sessionChanges
        )
        drafts.append(draft)
        
        // Update branch head
        if let idx = branches.firstIndex(where: { $0.name == activeBranchName }) {
            branches[idx].headDraftId = draft.id
        }
        
        workingDraft = nil
        sessionChanges = []
        lastModified = Date()
    }
    
    func restoreDraft(_ draft: Draft) {
        if hasUnsavedChanges {
            let snapshot = Draft(
                name: "Auto-Snapshot",
                content: currentContent,
                comment: "Snapshot before restoring '\(draft.name)'",
                parentId: currentBranchHead?.id,
                branchName: activeBranchName,
                changes: sessionChanges
            )
            drafts.append(snapshot)
            if let idx = branches.firstIndex(where: { $0.name == activeBranchName }) {
                branches[idx].headDraftId = snapshot.id
            }
        }
        currentContent = draft.content
        sessionChanges = []
        scheduleWorkingDraftUpdate()
    }
    
    // MARK: - Branch Management
    
    func createBranch(name: String, description: String = "") {
        guard let headDraft = currentBranchHead else { return }
        
        // Auto-save current changes before branching
        if hasUnsavedChanges {
            saveDraft(name: "Pre-branch snapshot", comment: "Auto-saved before branching to '\(name)'")
        }
        
        let branchPointId = currentBranchHead?.id ?? headDraft.id
        let newBranch = Branch(
            name: name,
            headDraftId: branchPointId,
            branchPoint: branchPointId,
            description: description
        )
        branches.append(newBranch)
        activeBranchName = name
    }
    
    func switchBranch(to name: String) {
        guard let branch = branches.first(where: { $0.name == name }) else { return }
        guard let headDraft = drafts.first(where: { $0.id == branch.headDraftId }) else { return }
        
        // Auto-save if needed
        if hasUnsavedChanges {
            saveDraft(name: "Auto-save", comment: "Auto-saved before switching to '\(name)'")
        }
        
        currentContent = headDraft.content
        activeBranchName = name
        sessionChanges = []
        scheduleWorkingDraftUpdate()
    }
    
    func mergeBranch(sourceName: String) -> MergeResult? {
        guard let sourceBranch = branches.first(where: { $0.name == sourceName }) else { return nil }
        guard let sourceHead = drafts.first(where: { $0.id == sourceBranch.headDraftId }) else { return nil }
        guard let branchPoint = drafts.first(where: { $0.id == sourceBranch.branchPoint }) else { return nil }
        
        let result = DiffGenerator.threeWayMerge(
            ancestor: branchPoint.content,
            ours: currentContent,
            theirs: sourceHead.content
        )
        
        if result.isClean {
            currentContent = result.mergedContent
            
            // Create merge commit
            let mergeCommit = Draft(
                name: "Merge '\(sourceName)' into '\(activeBranchName)'",
                content: result.mergedContent,
                comment: "Merged branch '\(sourceName)'",
                parentId: currentBranchHead?.id,
                secondParentId: sourceHead.id,
                branchName: activeBranchName,
                changes: sessionChanges
            )
            drafts.append(mergeCommit)
            
            if let idx = branches.firstIndex(where: { $0.name == activeBranchName }) {
                branches[idx].headDraftId = mergeCommit.id
            }
            
            sessionChanges = []
        }
        
        return result
    }
    
    func deleteBranch(_ name: String) {
        guard name != "main" && name != activeBranchName else { return }
        branches.removeAll { $0.name == name }
    }
    
    var currentBranchHead: Draft? {
        guard let branch = branches.first(where: { $0.name == activeBranchName }) else {
            return drafts.last
        }
        return drafts.first(where: { $0.id == branch.headDraftId })
    }
    
    var branchNames: [String] { branches.map(\.name) }
    
    var currentBranchDrafts: [Draft] {
        drafts.filter { $0.branchName == activeBranchName }
    }
    
    // MARK: - Change Tracking
    
    func recordChange(_ change: SemanticChange) {
        DispatchQueue.main.async { [weak self] in
            self?.sessionChanges.append(change)
            self?.scheduleWorkingDraftUpdate()
        }
    }
    
    func removeLastChange(matching change: SemanticChange) {
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            if let idx = self.sessionChanges.lastIndex(where: { $0.id == change.id }) {
                self.sessionChanges.remove(at: idx)
            }
        }
    }
    
    /// Re-add a change (for redo synchronization)
    func reAddChange(_ change: SemanticChange) {
        DispatchQueue.main.async { [weak self] in
            self?.sessionChanges.append(change)
        }
    }
    
    /// Debounced working draft update — avoids thrashing on rapid edits
    func scheduleWorkingDraftUpdate() {
        workingDraftTimer?.invalidate()
        workingDraftTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: false) { [weak self] _ in
            guard let self = self else { return }
            DispatchQueue.main.async {
                self.workingDraft = WorkingDraft(
                    content: self.currentContent,
                    pendingChanges: self.sessionChanges
                )
                self.lastModified = Date()
            }
        }
    }
    
    /// Immediate working draft update (for explicit saves)
    func updateWorkingDraftNow() {
        workingDraftTimer?.invalidate()
        workingDraft = WorkingDraft(content: currentContent, pendingChanges: sessionChanges)
        lastModified = Date()
    }
    
    // MARK: - Annotations
    
    func addAnnotation(text: String, anchorText: String, position: Int, category: AnnotationCategory = .note) {
        let annotation = Annotation(text: text, anchorText: anchorText, anchorPosition: position, category: category)
        annotations.append(annotation)
    }
    
    func updateAnnotation(_ annotationId: UUID, text: String? = nil, category: AnnotationCategory? = nil) {
        guard let idx = annotations.firstIndex(where: { $0.id == annotationId }) else { return }
        if let text = text { annotations[idx].text = text }
        if let category = category { annotations[idx].category = category }
        annotations[idx].updatedAt = Date()
    }
    
    func resolveAnnotation(_ annotation: Annotation) {
        if let idx = annotations.firstIndex(where: { $0.id == annotation.id }) {
            annotations[idx].resolved = true
            annotations[idx].updatedAt = Date()
        }
    }
    
    func unresolveAnnotation(_ annotation: Annotation) {
        if let idx = annotations.firstIndex(where: { $0.id == annotation.id }) {
            annotations[idx].resolved = false
            annotations[idx].updatedAt = Date()
        }
    }
    
    func deleteAnnotation(_ annotation: Annotation) {
        annotations.removeAll { $0.id == annotation.id }
    }
    
    /// Refresh all annotation positions against current content
    func refreshAnnotationPositions() {
        for i in annotations.indices {
            annotations[i].updateAnchorPosition(in: currentContent)
        }
    }
    
    var unresolvedAnnotations: [Annotation] {
        annotations.filter { !$0.resolved }
    }
    
    var annotationsByCategory: [AnnotationCategory: [Annotation]] {
        Dictionary(grouping: annotations.filter { !$0.resolved }, by: \.category)
    }
    
    // MARK: - Computed Properties
    
    var hasUnsavedChanges: Bool {
        guard let head = currentBranchHead else { return !currentContent.isEmpty }
        return currentContent != head.content || !sessionChanges.isEmpty
    }
    
    var latestDraft: Draft? { drafts.last }
    
    var allDarlings: [(text: String, draft: String, date: Date)] {
        var result: [(text: String, draft: String, date: Date)] = []
        for draft in drafts {
            for darling in draft.darlings {
                result.append((text: darling, draft: draft.name, date: draft.timestamp))
            }
        }
        for change in sessionChanges {
            if let lost = change.lostText, !lost.isEmpty {
                result.append((text: lost, draft: "Current session", date: change.timestamp))
            }
        }
        return result.reversed()
    }
    
    var sessionChangeSummary: String {
        guard !sessionChanges.isEmpty else { return "No changes" }
        return ChangeSummary(changes: sessionChanges).text
    }
    
    private var formattedNow: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, h:mm a"
        return formatter.string(from: Date())
    }
}

==================================================
FILE: Thesis/DiffGenerator.swift
==================================================

// DiffGenerator.swift — Thesis
// Sentence-level semantic diff with LCS matching, move detection, word-level sub-diffs

import Foundation

// MARK: - DiffChange

struct DiffChange: Identifiable {
    let id = UUID()
    let type: ChangeType
    let semanticType: SemanticChangeType?
    let range: NSRange
    let text: String
    let displayRange: NSRange?
    let oldText: String?
    let wordDiffs: [WordDiff]?    // Word-level sub-diff for modified sentences
    
    enum ChangeType {
        case addition
        case deletion
        case unchanged
        case moved                // Sentence exists in both but different position
    }
    
    init(
        type: ChangeType,
        range: NSRange,
        text: String,
        displayRange: NSRange? = nil,
        semanticType: SemanticChangeType? = nil,
        oldText: String? = nil,
        wordDiffs: [WordDiff]? = nil
    ) {
        self.type = type
        self.range = range
        self.text = text
        self.displayRange = displayRange
        self.semanticType = semanticType
        self.oldText = oldText
        self.wordDiffs = wordDiffs
    }
}

// MARK: - Word-Level Diff (for showing changes within a modified sentence)

struct WordDiff: Identifiable {
    let id = UUID()
    let type: DiffChange.ChangeType
    let text: String
}

// MARK: - Diff Statistics

struct EditorDiffInfo {
    let currentIndex: Int
    let totalChanges: Int
    let currentChange: DiffChange?
}

struct DiffStatistics {
    let added: Int
    let deleted: Int
    let refined: Int
    let replaced: Int
    let moved: Int
    let totalChanges: Int
    
    var summary: String {
        var parts: [String] = []
        if added > 0    { parts.append("+\(added) added") }
        if deleted > 0  { parts.append("-\(deleted) deleted") }
        if refined > 0  { parts.append("~\(refined) refined") }
        if replaced > 0 { parts.append("⇄\(replaced) replaced") }
        if moved > 0    { parts.append("↕\(moved) moved") }
        return parts.isEmpty ? "No changes" : parts.joined(separator: ", ")
    }
}

// MARK: - DiffGenerator

class DiffGenerator {
    
    /// Generate a sentence-level diff using LCS matching with semantic enrichment
    static func generateDiff(
        from oldText: String,
        to newText: String,
        withChanges changes: [SemanticChange] = []
    ) -> [DiffChange] {
        let oldSentences = TextAnalyzer.getSentences(in: oldText)
        let newSentences = TextAnalyzer.getSentences(in: newText)
        
        let normalize: (String) -> String = { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
        
        let oldNorm = oldSentences.map { normalize($0.text) }
        let newNorm = newSentences.map { normalize($0.text) }
        
        // Build semantic change lookup
        var semanticMap: [String: SemanticChange] = [:]
        for change in changes {
            if let afterText = change.afterText {
                semanticMap[normalize(afterText)] = change
            }
        }
        
        // LCS to find longest common subsequence of sentences
        let lcs = longestCommonSubsequence(oldNorm, newNorm)
        
        // Build sets for quick lookup
        let oldNormSet = NSCountedSet(array: oldNorm)
        let newNormSet = NSCountedSet(array: newNorm)
        
        // Detect moves: sentences present in both but not in LCS alignment
        var movedSentences = Set<String>()
        for sentence in oldNorm {
            if newNormSet.contains(sentence) && !lcs.contains(sentence) {
                movedSentences.insert(sentence)
            }
        }
        
        var diffChanges: [DiffChange] = []
        var currentLocation = 0
        
        // Process new sentences
        for (i, newSentence) in newSentences.enumerated() {
            let norm = newNorm[i]
            let range = NSRange(location: currentLocation, length: newSentence.text.count)
            
            if lcs.contains(norm) || (oldNormSet.contains(norm) && !movedSentences.contains(norm)) {
                diffChanges.append(DiffChange(type: .unchanged, range: range, text: newSentence.text))
            } else if movedSentences.contains(norm) {
                diffChanges.append(DiffChange(
                    type: .moved, range: range, text: newSentence.text,
                    semanticType: .moved
                ))
            } else {
                let changeRecord = semanticMap[norm]
                let semanticType = changeRecord?.type ?? .added
                let previousVersion = changeRecord?.beforeText
                
                // Generate word-level sub-diff if we have the old version
                var wordDiffs: [WordDiff]? = nil
                if let oldVersion = previousVersion, !oldVersion.isEmpty {
                    wordDiffs = generateWordDiff(from: oldVersion, to: newSentence.text)
                }
                
                diffChanges.append(DiffChange(
                    type: .addition, range: range, text: newSentence.text,
                    semanticType: semanticType, oldText: previousVersion,
                    wordDiffs: wordDiffs
                ))
            }
            currentLocation += newSentence.text.count
        }
        
        // Find deletions (sentences in old but not in new)
        for (index, oldSentence) in oldSentences.enumerated() {
            let norm = oldNorm[index]
            guard !newNormSet.contains(norm) else { continue }
            
            // Find display anchor position
            var displayLocation = 0
            for i in (0..<index).reversed() {
                if newNormSet.contains(oldNorm[i]) {
                    if let match = newSentences.first(where: { normalize($0.text) == oldNorm[i] }) {
                        displayLocation = match.range.location + match.range.length
                        break
                    }
                }
            }
            
            let semanticType = findSemanticTypeForDeletion(norm, in: changes)
            
            diffChanges.append(DiffChange(
                type: .deletion, range: oldSentence.range, text: oldSentence.text,
                displayRange: NSRange(location: displayLocation, length: 0),
                semanticType: semanticType
            ))
        }
        
        // Sort by display position
        diffChanges.sort { lhs, rhs in
            let lhsLoc = lhs.type == .deletion ? (lhs.displayRange?.location ?? 0) : lhs.range.location
            let rhsLoc = rhs.type == .deletion ? (rhs.displayRange?.location ?? 0) : rhs.range.location
            if lhsLoc == rhsLoc {
                if lhs.type == .deletion && rhs.type != .deletion { return true }
                if lhs.type != .deletion && rhs.type == .deletion { return false }
            }
            return lhsLoc < rhsLoc
        }
        
        return diffChanges
    }
    
    // MARK: - LCS (Longest Common Subsequence)
    
    private static func longestCommonSubsequence(_ a: [String], _ b: [String]) -> Set<String> {
        let m = a.count, n = b.count
        guard m > 0 && n > 0 else { return [] }
        
        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
        for i in 1...m {
            for j in 1...n {
                if a[i-1] == b[j-1] {
                    dp[i][j] = dp[i-1][j-1] + 1
                } else {
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                }
            }
        }
        
        var result = Set<String>()
        var i = m, j = n
        while i > 0 && j > 0 {
            if a[i-1] == b[j-1] {
                result.insert(a[i-1])
                i -= 1; j -= 1
            } else if dp[i-1][j] > dp[i][j-1] {
                i -= 1
            } else {
                j -= 1
            }
        }
        return result
    }
    
    // MARK: - Word-Level Sub-Diff
    
    static func generateWordDiff(from oldText: String, to newText: String) -> [WordDiff] {
        let oldWords = oldText.split(separator: " ", omittingEmptySubsequences: false).map(String.init)
        let newWords = newText.split(separator: " ", omittingEmptySubsequences: false).map(String.init)
        
        let m = oldWords.count, n = newWords.count
        guard m > 0 || n > 0 else { return [] }
        
        // Simple LCS for words
        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
        for i in 1...max(1, m) {
            for j in 1...max(1, n) {
                if i <= m && j <= n && oldWords[i-1] == newWords[j-1] {
                    dp[i][j] = dp[i-1][j-1] + 1
                } else {
                    dp[i][j] = max(i > 0 ? dp[i-1][j] : 0, j > 0 ? dp[i][j-1] : 0)
                }
            }
        }
        
        // Backtrack
        var diffs: [WordDiff] = []
        var i = m, j = n
        var stack: [WordDiff] = []
        
        while i > 0 || j > 0 {
            if i > 0 && j > 0 && oldWords[i-1] == newWords[j-1] {
                stack.append(WordDiff(type: .unchanged, text: newWords[j-1]))
                i -= 1; j -= 1
            } else if j > 0 && (i == 0 || dp[i][j-1] >= dp[i-1][j]) {
                stack.append(WordDiff(type: .addition, text: newWords[j-1]))
                j -= 1
            } else if i > 0 {
                stack.append(WordDiff(type: .deletion, text: oldWords[i-1]))
                i -= 1
            }
        }
        
        return stack.reversed()
    }
    
    // MARK: - Helpers
    
    private static func findSemanticTypeForDeletion(
        _ deletedText: String,
        in changes: [SemanticChange]
    ) -> SemanticChangeType? {
        let normalize: (String) -> String = { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
        for change in changes {
            if let before = change.beforeText, normalize(before) == deletedText {
                return change.type
            }
        }
        return .deleted
    }
    
    static func getChangeIndices(in diff: [DiffChange]) -> [Int] {
        diff.enumerated()
            .filter { $0.element.type != .unchanged }
            .map { $0.offset }
    }
    
    static func findNextChange(from currentIndex: Int, in diff: [DiffChange]) -> Int? {
        getChangeIndices(in: diff).first { $0 > currentIndex }
    }
    
    static func findPreviousChange(from currentIndex: Int, in diff: [DiffChange]) -> Int? {
        getChangeIndices(in: diff).last { $0 < currentIndex }
    }
    
    static func statistics(for diff: [DiffChange]) -> DiffStatistics {
        var added = 0, deleted = 0, refined = 0, replaced = 0, moved = 0
        for change in diff {
            switch change.type {
            case .addition:
                switch change.semanticType {
                case .refined:  refined += 1
                case .replaced: replaced += 1
                default:        added += 1
                }
            case .deletion:
                if change.semanticType != .refined && change.semanticType != .replaced {
                    deleted += 1
                }
            case .moved: moved += 1
            case .unchanged: break
            }
        }
        return DiffStatistics(
            added: added, deleted: deleted, refined: refined,
            replaced: replaced, moved: moved,
            totalChanges: added + deleted + refined + replaced + moved
        )
    }
    
    // MARK: - Three-Way Merge (for branch merging)
    
    /// Generate a three-way merge from common ancestor, ours, and theirs
    static func threeWayMerge(
        ancestor: String,
        ours: String,
        theirs: String
    ) -> MergeResult {
        let ancestorSentences = TextAnalyzer.getSentences(in: ancestor)
        let ourSentences = TextAnalyzer.getSentences(in: ours)
        let theirSentences = TextAnalyzer.getSentences(in: theirs)
        
        let normalize: (String) -> String = { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
        
        let ancestorNorm = Set(ancestorSentences.map { normalize($0.text) })
        let ourNorm = ourSentences.map { normalize($0.text) }
        let theirNorm = Set(theirSentences.map { normalize($0.text) })
        
        var merged = ""
        var conflicts: [MergeConflict] = []
        
        // Walk through our sentences
        for sentence in ourSentences {
            let norm = normalize(sentence.text)
            
            if ancestorNorm.contains(norm) && theirNorm.contains(norm) {
                // Unchanged in both — keep
                merged += sentence.text
            } else if ancestorNorm.contains(norm) && !theirNorm.contains(norm) {
                // Deleted by theirs — omit (theirs wins for deletions)
            } else if !ancestorNorm.contains(norm) {
                // Added by us — keep
                merged += sentence.text
            } else {
                // Modified — potential conflict
                merged += sentence.text
            }
        }
        
        // Add sentences that theirs added (not in ancestor, not in ours)
        for sentence in theirSentences {
            let norm = normalize(sentence.text)
            if !ancestorNorm.contains(norm) && !Set(ourNorm).contains(norm) {
                merged += sentence.text
            }
        }
        
        // Detect conflicts: sentences modified in both branches differently
        for ancestorSentence in ancestorSentences {
            let norm = normalize(ancestorSentence.text)
            let inOurs = Set(ourNorm).contains(norm)
            let inTheirs = theirNorm.contains(norm)
            
            if !inOurs && !inTheirs {
                // Both branches modified/deleted this sentence — conflict
                conflicts.append(MergeConflict(
                    position: ancestorSentence.range.location,
                    ourText: "Modified in current branch",
                    theirText: "Modified in other branch",
                    commonAncestorText: ancestorSentence.text
                ))
            }
        }
        
        return MergeResult(
            mergedContent: merged,
            conflicts: conflicts,
            hasUnresolvedConflicts: !conflicts.isEmpty
        )
    }
}

==================================================
FILE: Thesis/DocumentManager.swift
==================================================

// DocumentManager.swift — Thesis
// Document persistence and lifecycle management

import Foundation
import Combine

class DocumentManager: ObservableObject {
    @Published var documents: [Document] = []
    @Published var selectedDocument: Document?
    
    private let saveURL: URL
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let thesisDir = appSupport.appendingPathComponent("Thesis", isDirectory: true)
        try? FileManager.default.createDirectory(at: thesisDir, withIntermediateDirectories: true)
        saveURL = thesisDir.appendingPathComponent("documents.json")
        loadDocuments()
        
        $selectedDocument
            .debounce(for: .seconds(2), scheduler: RunLoop.main)
            .sink { [weak self] _ in self?.saveDocuments() }
            .store(in: &cancellables)
    }
    
    func createNewDocument() {
        let doc = Document(title: "New Thought")
        documents.insert(doc, at: 0)
        selectedDocument = doc
        saveDocuments()
    }
    
    func deleteDocument(_ doc: Document) {
        documents.removeAll { $0.id == doc.id }
        if selectedDocument?.id == doc.id { selectedDocument = documents.first }
        saveDocuments()
    }
    
    func saveDocuments() {
        do {
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            encoder.outputFormatting = .prettyPrinted
            let data = try encoder.encode(documents)
            try data.write(to: saveURL, options: .atomic)
        } catch {
            print("Save error: \(error)")
        }
    }
    
    private func loadDocuments() {
        guard FileManager.default.fileExists(atPath: saveURL.path) else { return }
        do {
            let data = try Data(contentsOf: saveURL)
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            documents = try decoder.decode([Document].self, from: data)
            selectedDocument = documents.first
        } catch {
            print("Load error: \(error)")
        }
    }
}

==================================================
FILE: Thesis/EditorTextView.swift
==================================================

// EditorTextView.swift — Thesis
// NSViewRepresentable wrapping NSTextView with modal editing support

import SwiftUI
import AppKit

struct EditorTextView: NSViewRepresentable {
    @Binding var text: String
    @Binding var mode: EditorMode
    @Binding var cursorPosition: Int
    @Binding var highlightRange: NSRange?
    @Binding var flashRange: NSRange?
    @Binding var selectionRange: NSRange?
    @Binding var diffChanges: [DiffChange]
    
    let onTextChange: () -> Void
    let onKeyPress: (String, NSEvent.ModifierFlags) -> Void
    let onModeChange: (EditorMode) -> Void
    
    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = NSScrollView()
        scrollView.hasVerticalScroller = true
        scrollView.autohidesScrollers = true
        scrollView.borderType = .noBorder
        
        let contentSize = scrollView.contentSize
        let textContainer = NSTextContainer(
            containerSize: NSSize(width: contentSize.width, height: .greatestFiniteMagnitude)
        )
        textContainer.widthTracksTextView = true
        
        let layoutManager = NSLayoutManager()
        layoutManager.addTextContainer(textContainer)
        
        let textStorage = NSTextStorage()
        textStorage.addLayoutManager(layoutManager)
        
        let textView = ModalNSTextView(
            frame: NSRect(origin: .zero, size: contentSize),
            textContainer: textContainer
        )
        textView.minSize = NSSize(width: 0, height: contentSize.height)
        textView.maxSize = NSSize(width: .greatestFiniteMagnitude, height: .greatestFiniteMagnitude)
        textView.isVerticallyResizable = true
        textView.autoresizingMask = [.width]
        textView.font = NSFont.monospacedSystemFont(ofSize: 14, weight: .regular)
        textView.isAutomaticQuoteSubstitutionEnabled = false
        textView.isAutomaticDashSubstitutionEnabled = false
        textView.isAutomaticSpellingCorrectionEnabled = false
        textView.allowsUndo = false
        textView.drawsBackground = true
        textView.backgroundColor = NSColor.textBackgroundColor
        textView.textContainerInset = NSSize(width: 20, height: 20)
        textView.delegate = context.coordinator
        
        let coordinator = context.coordinator
        textView.onKeyPress = { key, mods in
            coordinator.parent.onKeyPress(key, mods)
        }
        
        scrollView.documentView = textView
        return scrollView
    }
    
    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = scrollView.documentView as? ModalNSTextView else { return }
        textView.currentMode = mode
        textView.diffChanges = diffChanges
        
        if textView.string != text {
            textView.string = text
        }
        
        switch mode {
        case .freeText, .insert:
            textView.isEditable = true
            textView.isSelectable = true
        default:
            textView.isEditable = false
            textView.isSelectable = true
        }
        
        let safePos = min(cursorPosition, textView.string.count)
        if textView.selectedRange().location != safePos {
            textView.setSelectedRange(NSRange(location: safePos, length: 0))
            textView.scrollRangeToVisible(NSRange(location: safePos, length: 0))
        }
        
        applyHighlights(to: textView)
    }
    
    private func applyHighlights(to textView: ModalNSTextView) {
        guard let layoutManager = textView.layoutManager,
              let textStorage = textView.textStorage else { return }
        
        let fullRange = NSRange(location: 0, length: textStorage.length)
        guard fullRange.length > 0 else { return }
        
        layoutManager.removeTemporaryAttribute(.backgroundColor, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.foregroundColor, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.strikethroughStyle, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.underlineStyle, forCharacterRange: fullRange)
        layoutManager.removeTemporaryAttribute(.underlineColor, forCharacterRange: fullRange)
        
        let safe: (NSRange) -> NSRange = { r in
            TextAnalyzer.safeRange(r, in: textStorage.length)
        }
        
        if let selection = selectionRange, case .visual = mode {
            let r = safe(selection)
            if r.length > 0 {
                layoutManager.addTemporaryAttribute(
                    .backgroundColor,
                    value: NSColor.selectedTextBackgroundColor.withAlphaComponent(0.4),
                    forCharacterRange: r
                )
            }
        }
        
        if let highlight = highlightRange {
            let r = safe(highlight)
            if r.length > 0 {
                layoutManager.addTemporaryAttribute(
                    .backgroundColor,
                    value: NSColor.systemYellow.withAlphaComponent(0.3),
                    forCharacterRange: r
                )
            }
        }
        
        if let flash = flashRange {
            let r = safe(flash)
            if r.length > 0 {
                layoutManager.addTemporaryAttribute(
                    .backgroundColor,
                    value: NSColor.systemBlue.withAlphaComponent(0.3),
                    forCharacterRange: r
                )
            }
        }
        
        if mode == .comp {
            for change in diffChanges {
                switch change.type {
                case .addition:
                    let r = safe(change.range)
                    guard r.length > 0 else { continue }
                    let color: NSColor = {
                        switch change.semanticType {
                        case .refined:  return .systemBlue
                        case .replaced: return .systemOrange
                        default:        return .systemGreen
                        }
                    }()
                    layoutManager.addTemporaryAttribute(
                        .backgroundColor, value: color.withAlphaComponent(0.2),
                        forCharacterRange: r
                    )
                case .moved:
                    let r = safe(change.range)
                    guard r.length > 0 else { continue }
                    layoutManager.addTemporaryAttribute(
                        .backgroundColor,
                        value: NSColor.systemPurple.withAlphaComponent(0.15),
                        forCharacterRange: r
                    )
                case .deletion, .unchanged:
                    break
                }
            }
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EditorTextView
        private var isUpdating = false
        
        init(_ parent: EditorTextView) { self.parent = parent }
        
        func textDidChange(_ notification: Notification) {
            guard !isUpdating else { return }
            guard let textView = notification.object as? NSTextView else { return }
            isUpdating = true
            parent.text = textView.string
            parent.cursorPosition = textView.selectedRange().location
            parent.onTextChange()
            isUpdating = false
        }
    }
}

// MARK: - Custom NSTextView

class ModalNSTextView: NSTextView {
    var currentMode: EditorMode = .freeText
    var diffChanges: [DiffChange] = []
    var onKeyPress: ((String, NSEvent.ModifierFlags) -> Void)?
    
    override func keyDown(with event: NSEvent) {
        let chars = event.charactersIgnoringModifiers ?? ""
        let modifiers = event.modifierFlags
        
        switch currentMode {
        case .freeText:
            if chars == "\u{1B}" { onKeyPress?(chars, modifiers); return }
            super.keyDown(with: event)
            
        case .insert:
            if chars == "\u{1B}" { onKeyPress?(chars, modifiers); return }
            super.keyDown(with: event)
            DispatchQueue.main.async { [weak self] in
                self?.onKeyPress?(chars, modifiers)
            }
            
        case .normal, .visual, .command, .comp:
            onKeyPress?(chars, modifiers)
        }
    }
    
    override func mouseDown(with event: NSEvent) {
        switch currentMode {
        case .freeText, .insert, .normal, .visual, .comp:
            super.mouseDown(with: event)
        case .command:
            break
        }
    }
}

==================================================
FILE: Thesis/ModalEditor.swift
==================================================

// ModalEditor.swift — Thesis
// Core modal editor: key handling, navigation, verb-object, visual mode,
// move command, repeat (.), redo, gg/G, improved insert tracking

import SwiftUI
import AppKit

struct ModalEditor: View {
    @Binding var document: Document
    var onNavigateToAnnotation: ((Annotation) -> Void)?
    
    // Mode state
    @State private var mode: EditorMode = .freeText
    @State private var pendingVerb: PendingVerb?
    @State private var insertContext: InsertContext?
    
    // Cursor and selection
    @State private var cursorPosition: Int = 0
    @State private var visualAnchor: Int = 0
    @State private var selectionRange: NSRange?
    
    // Highlights
    @State private var highlightRange: NSRange?
    @State private var flashRange: NSRange?
    
    // Move mode state
    @State private var movePayload: TextUnit?        // The text being moved
    @State private var movePayloadType: TextUnitType?
    
    // Version control
    @State private var diffChanges: [DiffChange] = []
    @State private var currentDiffIndex: Int = 0
    
    // Sheets
    @State private var showingFirstDraftSheet = false
    @State private var showingSaveSheet = false
    @State private var showingAnnotationSheet = false
    @State private var showingBranchSheet = false
    @State private var showingMergeSheet = false
    @State private var annotationAnchorText: String = ""
    @State private var annotationPosition: Int = 0
    
    // Stats (debounced)
    @State private var stats: TextAnalyzer.Stats = .init(paragraphCount: 0, sentenceCount: 0, wordCount: 0)
    @State private var statsTimer: Timer?
    
    // Tracking
    @State private var undoStack = UndoStack()
    @State private var pendingChangeTracker = PendingChangeTracker()
    @State private var lastCommand: LastCommand?
    @State private var analyzer = CachedTextAnalyzer()
    
    var body: some View {
        VStack(spacing: 0) {
            ZStack(alignment: .topTrailing) {
                EditorTextView(
                    text: $document.currentContent,
                    mode: $mode,
                    cursorPosition: $cursorPosition,
                    highlightRange: $highlightRange,
                    flashRange: $flashRange,
                    selectionRange: $selectionRange,
                    diffChanges: $diffChanges,
                    onTextChange: { handleTextChange() },
                    onKeyPress: { key, mods in handleKeyPress(key, modifiers: mods) },
                    onModeChange: { newMode in handleModeChange(newMode) }
                )
                .border(mode.borderColor, width: 3)
                
                if let verb = pendingVerb {
                    VerbHelpOverlay(verb: verb.verb)
                        .padding(8)
                        .transition(.opacity)
                }
                
                if movePayload != nil {
                    MoveIndicator()
                        .padding(8)
                        .transition(.opacity)
                }
            }
            
            StatusBar(
                mode: mode,
                pendingVerb: pendingVerb?.verb,
                stats: stats,
                draftInfo: draftInfo,
                hasUnsavedChanges: document.hasUnsavedChanges,
                branchInfo: branchInfo,
                diffInfo: currentDiffInfo,
                undoPreview: undoStack.undoPreview,
                annotationCount: document.unresolvedAnnotations.count,
                sessionSummary: document.sessionChangeSummary
            )
        }
        .onAppear {
            DispatchQueue.main.async { debouncedUpdateStats() }
            if !document.drafts.isEmpty { mode = .normal }
        }
        .sheet(isPresented: $showingFirstDraftSheet) {
            FirstDraftSheet(
                onSave: { name in
                    document.saveFirstDraft(name: name)
                    mode = .normal
                    showingFirstDraftSheet = false
                },
                onCancel: {
                    mode = .freeText
                    showingFirstDraftSheet = false
                }
            )
        }
        .sheet(isPresented: $showingSaveSheet) {
            SaveDraftSheet(
                sessionSummary: document.sessionChangeSummary,
                onSave: { name, comment in
                    document.saveDraft(name: name, comment: comment)
                    mode = .normal
                    showingSaveSheet = false
                    debouncedUpdateStats()
                }
            )
        }
        .sheet(isPresented: $showingAnnotationSheet) {
            AnnotationSheet(
                anchorText: annotationAnchorText,
                onSave: { noteText, category in
                    document.addAnnotation(
                        text: noteText,
                        anchorText: annotationAnchorText,
                        position: annotationPosition,
                        category: category
                    )
                    showingAnnotationSheet = false
                    mode = .normal
                }
            )
        }
        .sheet(isPresented: $showingBranchSheet) {
            BranchSheet(
                document: document,
                onCreateBranch: { name, desc in
                    document.createBranch(name: name, description: desc)
                    showingBranchSheet = false
                    mode = .normal
                },
                onSwitchBranch: { name in
                    document.switchBranch(to: name)
                    showingBranchSheet = false
                    mode = .normal
                    analyzer.invalidate()
                    debouncedUpdateStats()
                },
                onDeleteBranch: { name in
                    document.deleteBranch(name)
                }
            )
        }
        .sheet(isPresented: $showingMergeSheet) {
            MergeSheet(
                document: document,
                onMerge: { sourceBranch in
                    if let result = document.mergeBranch(sourceName: sourceBranch) {
                        if !result.isClean {
                            // TODO: conflict resolution UI
                        }
                    }
                    showingMergeSheet = false
                    mode = .normal
                    analyzer.invalidate()
                    debouncedUpdateStats()
                }
            )
        }
    }
    
    // MARK: - Computed Properties
    
    private var draftInfo: String {
        if let head = document.currentBranchHead {
            return "\(document.activeBranchName): \(head.name)"
        }
        return "No draft saved"
    }
    
    private var branchInfo: String? {
        if document.branches.count > 1 {
            return "[\(document.activeBranchName)]"
        }
        return nil
    }
    
    private var currentDiffInfo: EditorDiffInfo? {
        guard mode == .comp, !diffChanges.isEmpty else { return nil }
        let changeIndices = DiffGenerator.getChangeIndices(in: diffChanges)
        guard !changeIndices.isEmpty else { return nil }
        let currentChangeArrayIndex = changeIndices.firstIndex(of: currentDiffIndex) ?? 0
        return EditorDiffInfo(
            currentIndex: currentChangeArrayIndex,
            totalChanges: changeIndices.count,
            currentChange: currentDiffIndex < diffChanges.count ? diffChanges[currentDiffIndex] : nil
        )
    }
    
    // MARK: - Updates
    
    private func debouncedUpdateStats() {
        statsTimer?.invalidate()
        statsTimer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { _ in
            DispatchQueue.main.async {
                self.stats = self.analyzer.stats(for: self.document.currentContent)
            }
        }
    }
    
    private func handleTextChange() {
        analyzer.invalidate()
        debouncedUpdateStats()
        switch mode {
        case .insert, .freeText:
            document.scheduleWorkingDraftUpdate()
        default: break
        }
    }
    
    private func handleModeChange(_ newMode: EditorMode) {
        if case .insert = mode, !(newMode == mode) {
            completeInsertMode()
        }
        mode = newMode
        if case .normal = newMode {
            insertContext = nil
            pendingVerb = nil
            highlightRange = nil
        }
    }
    
    // MARK: - Key Dispatch
    
    private func handleKeyPress(_ characters: String, modifiers: NSEvent.ModifierFlags) {
        if modifiers.contains(.command) {
            if characters == "d" && mode == .normal { enterCompMode(); return }
            if characters == "s" && mode == .normal {
                if document.currentBranchHead != nil { showingSaveSheet = true }
                return
            }
            if characters == "z" && mode == .normal { executeUndo(); return }
            return
        }
        
        if modifiers.contains(.control) {
            if characters == "r" && mode == .normal { executeRedo(); return }
            return
        }
        
        switch mode {
        case .freeText:                handleFreeTextKey(characters)
        case .normal:                  handleNormalKey(characters, modifiers: modifiers)
        case .insert(let ctx):         handleInsertKey(characters, context: ctx)
        case .visual:                  handleVisualKey(characters, modifiers: modifiers)
        case .command(let cur):        handleCommandKey(characters, current: cur)
        case .comp:                    handleCompKey(characters)
        }
    }
    
    // MARK: - Free Text Mode
    
    private func handleFreeTextKey(_ chars: String) {
        if chars == "\u{1B}" && !document.currentContent.isEmpty {
            showingFirstDraftSheet = true
        }
    }
    
    // MARK: - Insert Mode
    
    private func handleInsertKey(_ chars: String, context: InsertContext) {
        if chars == "\u{1B}" {
            completeInsertMode()
            return
        }
        guard context != .freeform else { return }
        if let char = chars.first, context.autoExitCharacters.contains(char) {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                self.completeInsertMode()
            }
        }
        if context.exitsOnDoubleNewline && chars == "\n" {
            // Check if previous character was also newline
            let text = document.currentContent
            let nsText = text as NSString
            if cursorPosition > 0 && cursorPosition <= nsText.length {
                let prevChar = nsText.substring(with: NSRange(location: cursorPosition - 1, length: 1))
                if prevChar == "\n" {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                        self.completeInsertMode()
                    }
                }
            }
        }
    }
    
    private func completeInsertMode() {
        if pendingChangeTracker.hasPending {
            if let completed = pendingChangeTracker.completeChange(
                currentContent: document.currentContent,
                cursorPosition: cursorPosition
            ) {
                document.recordChange(completed)
                
                // Build undo operation for the insert phase
                if let startPos = pendingChangeTracker.insertStartPosition {
                    let length = cursorPosition - startPos
                    if length > 0 {
                        let nsText = document.currentContent as NSString
                        let safeRange = TextAnalyzer.safeRange(
                            NSRange(location: startPos, length: length),
                            in: nsText.length
                        )
                        let insertedText = nsText.substring(with: safeRange)
                        let operation = InsertOperation(
                            position: startPos,
                            insertedText: insertedText,
                            semanticChange: completed
                        )
                        undoStack.push(operation)
                    }
                }
            }
        }
        mode = .normal
        insertContext = nil
        pendingVerb = nil
        highlightRange = nil
        movePayload = nil
        movePayloadType = nil
    }
    
    // MARK: - Normal Mode
    
    private func handleNormalKey(_ chars: String, modifiers: NSEvent.ModifierFlags) {
        guard let rawChar = chars.first else { return }
        let char = String(rawChar)
        let isShift = modifiers.contains(.shift)
        
        // Move placement mode: j/k to position, Enter to confirm, ESC to cancel
        if let payload = movePayload, let payloadType = movePayloadType {
            handleMoveKey(char, payload: payload, payloadType: payloadType)
            return
        }
        
        // Pending verb → object
        if let verb = pendingVerb {
            if char == "\u{1B}" {
                pendingVerb = nil
                highlightRange = nil
                return
            }
            if let obj = parseObject(char.lowercased()) {
                updateLiveHighlightForObject(verb: verb.verb, object: obj)
            }
            executeVerbObject(verb: verb.verb, objectKey: char.lowercased(), isShift: isShift)
            pendingVerb = nil
            highlightRange = nil
            return
        }
        
        switch char.lowercased() {
        // Navigation
        case "h":
            if isShift { navigateSentence(forward: false) }
            else { navigateClause(forward: false) }
        case "l":
            if isShift { navigateSentence(forward: true) }
            else { navigateClause(forward: true) }
        case "j":
            if isShift { navigateLine(forward: true) }
            else { navigateParagraph(forward: true) }
        case "k":
            if isShift { navigateLine(forward: false) }
            else { navigateParagraph(forward: false) }
        case "w":
            navigateWord(forward: true)
        case "b":
            navigateWord(forward: false)
            
        // Jump to top/bottom
        case "g":
            if char == "g" { cursorPosition = 0; flashCursor() }
        case "G" where chars == "G":
            cursorPosition = (document.currentContent as NSString).length
            flashCursor()
            
        // Verbs
        case "d":
            if isShift { executeDeleteToEnd() }
            else { startPendingVerb(.delete) }
        case "c":
            if isShift { executeChangeToEnd() }
            else { startPendingVerb(.change) }
        case "r":
            if isShift { executeRefineToEnd() }
            else { startPendingVerb(.refine) }
        case "y":
            startPendingVerb(.yank)
        case "m":
            startPendingVerb(.markup)
        case "x":
            startPendingVerb(.move)
            
        // Direct actions
        case "i":
            startInsert(context: .freeform)
        case "a":
            executeAppendAfterSentence()
        case "o":
            executeOpenLineBelow()
        case "p":
            executePaste()
        case "u":
            executeUndo()
        case ".":
            repeatLastCommand()
            
        // Mode switches
        case "v":
            enterVisualMode()
        case ":":
            mode = .command("")
            
        default:
            break
        }
    }
    
    private func startPendingVerb(_ verb: EditVerb) {
        pendingVerb = PendingVerb(verb)
        updateLiveHighlight(for: verb)
    }
    
    /// Default highlight: sentence at cursor
    private func updateLiveHighlight(for verb: EditVerb) {
        if let sentence = analyzer.sentenceAt(cursorPosition, in: document.currentContent) {
            highlightRange = sentence.range
        }
    }
    
    /// Update highlight as user types the object key
    private func updateLiveHighlightForObject(verb: EditVerb, object: EditObject) {
        if let unit = resolveUnit(for: object) {
            highlightRange = unit.range
        }
    }
    
    // MARK: - Verb + Object Execution
    
    private func executeVerbObject(verb: EditVerb, objectKey: String, isShift: Bool) {
        guard let object = parseObject(objectKey) else { return }
        guard let unit = resolveUnit(for: object) else { return }
        
        lastCommand = LastCommand(verb: verb, object: object, insertedText: nil)
        
        switch verb {
        case .delete: executeDelete(unit: unit, unitType: objectTextUnitType(object))
        case .change: executeChange(unit: unit, unitType: objectTextUnitType(object), object: object)
        case .refine: executeRefine(unit: unit, unitType: objectTextUnitType(object), object: object)
        case .yank:   executeYank(unit: unit, unitType: objectTextUnitType(object))
        case .markup: executeMarkup(unit: unit, unitType: objectTextUnitType(object))
        case .move:   startMove(unit: unit, unitType: objectTextUnitType(object))
        }
    }
    
    private func parseObject(_ key: String) -> EditObject? {
        switch key {
        case "w": return .word
        case "b": return .wordBack
        case "c": return .clause
        case "s": return .sentence
        case "p": return .paragraph
        default:  return nil
        }
    }
    
    private func resolveUnit(for object: EditObject) -> TextUnit? {
        let text = document.currentContent
        let pos = cursorPosition
        switch object {
        case .word:      return analyzer.wordAt(pos, in: text)
        case .wordBack:  return analyzer.prevWord(from: pos, in: text)
        case .clause:    return analyzer.clauseAt(pos, in: text)
        case .sentence:  return analyzer.sentenceAt(pos, in: text)
        case .paragraph: return analyzer.paragraphAt(pos, in: text)
        }
    }
    
    private func objectTextUnitType(_ object: EditObject) -> TextUnitType {
        switch object {
        case .word, .wordBack: return .word
        case .clause:          return .clause
        case .sentence:        return .sentence
        case .paragraph:       return .paragraph
        }
    }
    
    private func objectInsertContext(_ object: EditObject) -> InsertContext {
        switch object {
        case .word, .wordBack: return .word
        case .clause:          return .clause
        case .sentence:        return .sentence
        case .paragraph:       return .paragraph
        }
    }
    
    // MARK: - Edit Operations
    
    private func executeDelete(unit: TextUnit, unitType: TextUnitType) {
        let range = unitType == .word
            ? TextAnalyzer.expandToTrailingSpace(unit.range, in: document.currentContent)
            : unit.range
        let change = SemanticChange(
            type: .deleted, unitType: unitType,
            beforeText: unit.text, position: cursorPosition,
            context: "deleted \(unitType.rawValue)"
        )
        highlightRangeBriefly(range) {
            self.performDelete(range: range, change: change)
        }
    }
    
    private func executeChange(unit: TextUnit, unitType: TextUnitType, object: EditObject) {
        let range = unitType == .word
            ? TextAnalyzer.expandToTrailingSpace(unit.range, in: document.currentContent)
            : unit.range
        let ctx = objectInsertContext(object)
        pendingChangeTracker.startChange(
            type: .replaced, unitType: unitType,
            beforeText: unit.text, position: range.location,
            context: "\(unitType.rawValue) replacement"
        )
        highlightRangeBriefly(range) {
            self.performDelete(range: range, change: nil)
            self.mode = .insert(ctx)
            self.insertContext = ctx
        }
    }
    
    private func executeRefine(unit: TextUnit, unitType: TextUnitType, object: EditObject) {
        let range = unitType == .word
            ? TextAnalyzer.expandToTrailingSpace(unit.range, in: document.currentContent)
            : unit.range
        let ctx = objectInsertContext(object)
        pendingChangeTracker.startChange(
            type: .refined, unitType: unitType,
            beforeText: unit.text, position: range.location,
            context: "\(unitType.rawValue) refinement"
        )
        highlightRangeBriefly(range) {
            self.performDelete(range: range, change: nil)
            self.mode = .insert(ctx)
            self.insertContext = ctx
        }
    }
    
    private func executeYank(unit: TextUnit, unitType: TextUnitType) {
        document.yankRegister = unit.text
        flashUnit(unit)
    }
    
    private func executeMarkup(unit: TextUnit, unitType: TextUnitType) {
        annotationAnchorText = unit.text
        annotationPosition = unit.range.location
        flashUnit(unit)
        showingAnnotationSheet = true
    }
    
    // MARK: - Move Operations
    
    private func startMove(unit: TextUnit, unitType: TextUnitType) {
        movePayload = unit
        movePayloadType = unitType
        flashUnit(unit)
        // User now presses j/k to navigate to target, Enter to confirm
    }
    
    private func handleMoveKey(_ char: String, payload: TextUnit, payloadType: TextUnitType) {
        switch char {
        case "j":
            navigateParagraph(forward: true)
        case "k":
            navigateParagraph(forward: false)
        case "\r", "\n":
            confirmMove(payload: payload, payloadType: payloadType)
        case "\u{1B}":
            movePayload = nil
            movePayloadType = nil
        default:
            break
        }
    }
    
    private func confirmMove(payload: TextUnit, payloadType: TextUnitType) {
        let destination = cursorPosition
        let nsText = document.currentContent as NSString
        let movedText = payload.text
        
        guard payload.range.location + payload.range.length <= nsText.length else {
            movePayload = nil
            movePayloadType = nil
            return
        }
        
        let change = SemanticChange(
            type: .moved, unitType: payloadType,
            beforeText: movedText,
            position: payload.range.location,
            context: "moved \(payloadType.rawValue) to position \(destination)"
        )
        
        let operation = MoveOperation(
            sourceRange: payload.range,
            movedText: movedText,
            destinationPosition: destination,
            cursorBefore: payload.range.location,
            semanticChange: change
        )
        
        // Execute the move
        var content = document.currentContent
        let _ = operation.redo(content: &content)
        document.currentContent = content
        
        undoStack.push(operation)
        document.recordChange(change)
        
        movePayload = nil
        movePayloadType = nil
        handleTextChange()
    }
    
    // MARK: - Shift Variants (to end of sentence)
    
    private func executeDeleteToEnd() {
        guard let rest = TextAnalyzer.getRestOfSentence(from: cursorPosition, in: document.currentContent) else { return }
        let change = SemanticChange(
            type: .deleted, unitType: .sentence,
            beforeText: rest.text, position: cursorPosition,
            context: "deleted to end"
        )
        highlightRangeBriefly(rest.range) {
            self.performDelete(range: rest.range, change: change)
        }
    }
    
    private func executeChangeToEnd() {
        guard let rest = TextAnalyzer.getRestOfSentence(from: cursorPosition, in: document.currentContent) else { return }
        pendingChangeTracker.startChange(
            type: .replaced, unitType: .sentence,
            beforeText: rest.text, position: rest.range.location,
            context: "change to end"
        )
        highlightRangeBriefly(rest.range) {
            self.performDelete(range: rest.range, change: nil)
            self.mode = .insert(.sentence)
            self.insertContext = .sentence
        }
    }
    
    private func executeRefineToEnd() {
        guard let rest = TextAnalyzer.getRestOfSentence(from: cursorPosition, in: document.currentContent) else { return }
        pendingChangeTracker.startChange(
            type: .refined, unitType: .sentence,
            beforeText: rest.text, position: rest.range.location,
            context: "refine to end"
        )
        highlightRangeBriefly(rest.range) {
            self.performDelete(range: rest.range, change: nil)
            self.mode = .insert(.sentence)
            self.insertContext = .sentence
        }
    }
    
    // MARK: - Direct Actions
    
    private func executeAppendAfterSentence() {
        let text = document.currentContent
        if let sentence = analyzer.sentenceAt(cursorPosition, in: text) {
            cursorPosition = sentence.endLocation
        }
        pendingChangeTracker.startChange(
            type: .added, unitType: .sentence,
            beforeText: nil, position: cursorPosition,
            context: "appended sentence"
        )
        mode = .insert(.sentence)
        insertContext = .sentence
    }
    
    private func executeOpenLineBelow() {
        let nsText = document.currentContent as NSString
        let range = NSRange(location: cursorPosition, length: nsText.length - cursorPosition)
        let nextNewline = nsText.range(of: "\n", options: [], range: range)
        let insertPos = nextNewline.location != NSNotFound ? nextNewline.location + 1 : nsText.length
        
        document.currentContent = (document.currentContent as NSString).replacingCharacters(
            in: NSRange(location: insertPos, length: 0), with: "\n"
        )
        cursorPosition = insertPos + 1
        
        pendingChangeTracker.startChange(
            type: .added, unitType: .paragraph,
            beforeText: nil, position: cursorPosition,
            context: "opened new line"
        )
        mode = .insert(.line)
        insertContext = .line
        handleTextChange()
    }
    
    private func executePaste() {
        guard let yanked = document.yankRegister, !yanked.isEmpty else { return }
        let nsText = document.currentContent as NSString
        let insertPos = min(cursorPosition, nsText.length)
        let change = SemanticChange(
            type: .added, unitType: .sentence,
            afterText: yanked, position: insertPos,
            context: "pasted from yank"
        )
        let operation = InsertOperation(position: insertPos, insertedText: yanked, semanticChange: change)
        document.currentContent = nsText.replacingCharacters(
            in: NSRange(location: insertPos, length: 0), with: yanked
        )
        cursorPosition = insertPos + yanked.count
        undoStack.push(operation)
        document.recordChange(change)
        handleTextChange()
    }
    
    private func executeUndo() {
        if let result = undoStack.undo(content: &document.currentContent) {
            cursorPosition = result.cursor
            if let change = result.change { document.removeLastChange(matching: change) }
            handleTextChange()
        }
    }
    
    private func executeRedo() {
        if let result = undoStack.redo(content: &document.currentContent) {
            cursorPosition = result.cursor
            if let change = result.change { document.reAddChange(change) }
            handleTextChange()
        }
    }
    
    private func repeatLastCommand() {
        guard let last = lastCommand else { return }
        guard let object = last.object else { return }
        guard let unit = resolveUnit(for: object) else { return }
        
        switch last.verb {
        case .delete: executeDelete(unit: unit, unitType: objectTextUnitType(object))
        case .change: executeChange(unit: unit, unitType: objectTextUnitType(object), object: object)
        case .refine: executeRefine(unit: unit, unitType: objectTextUnitType(object), object: object)
        case .yank:   executeYank(unit: unit, unitType: objectTextUnitType(object))
        case .markup: executeMarkup(unit: unit, unitType: objectTextUnitType(object))
        case .move:   startMove(unit: unit, unitType: objectTextUnitType(object))
        }
    }
    
    // MARK: - Visual Mode
    
    private func enterVisualMode() {
        visualAnchor = cursorPosition
        selectionRange = NSRange(location: cursorPosition, length: 0)
        mode = .visual(.character)
    }
    
    private func updateVisualSelection() {
        let start = min(visualAnchor, cursorPosition)
        let end = max(visualAnchor, cursorPosition)
        selectionRange = NSRange(location: start, length: end - start)
    }
    
    /// Snap visual selection to unit boundaries
    private func snapSelectionToUnit(_ granularity: VisualGranularity) {
        let text = document.currentContent
        let start = min(visualAnchor, cursorPosition)
        let end = max(visualAnchor, cursorPosition)
        
        var snappedStart = start
        var snappedEnd = end
        
        switch granularity {
        case .word:
            if let startWord = analyzer.wordAt(start, in: text) {
                snappedStart = startWord.range.location
            }
            if let endWord = analyzer.wordAt(end, in: text) {
                snappedEnd = endWord.endLocation
            }
        case .sentence:
            if let startSent = analyzer.sentenceAt(start, in: text) {
                snappedStart = startSent.range.location
            }
            if let endSent = analyzer.sentenceAt(end, in: text) {
                snappedEnd = endSent.endLocation
            }
        case .paragraph:
            if let startPara = analyzer.paragraphAt(start, in: text) {
                snappedStart = startPara.range.location
            }
            if let endPara = analyzer.paragraphAt(end, in: text) {
                snappedEnd = endPara.endLocation
            }
        case .character:
            break
        }
        
        selectionRange = NSRange(location: snappedStart, length: snappedEnd - snappedStart)
    }
    
    private func handleVisualKey(_ chars: String, modifiers: NSEvent.ModifierFlags) {
        guard let rawChar = chars.first else { return }
        let char = String(rawChar)
        let isShift = modifiers.contains(.shift)
        
        switch char.lowercased() {
        case "\u{1B}":
            selectionRange = nil
            mode = .normal
            
        // Navigation
        case "h":
            if isShift { navigateSentence(forward: false) }
            else { navigateClause(forward: false) }
            updateVisualSelection()
        case "l":
            if isShift { navigateSentence(forward: true) }
            else { navigateClause(forward: true) }
            updateVisualSelection()
        case "j":
            if isShift { navigateLine(forward: true) }
            else { navigateParagraph(forward: true) }
            updateVisualSelection()
        case "k":
            if isShift { navigateLine(forward: false) }
            else { navigateParagraph(forward: false) }
            updateVisualSelection()
        case "w":
            navigateWord(forward: true)
            updateVisualSelection()
        case "b":
            navigateWord(forward: false)
            updateVisualSelection()
            
        // Snap selection to semantic boundaries
        case "s":
            mode = .visual(.sentence)
            snapSelectionToUnit(.sentence)
        case "p" where selectionRange == nil || selectionRange?.length == 0:
            mode = .visual(.paragraph)
            snapSelectionToUnit(.paragraph)
            
        // Actions
        case "d":
            executeVisualAction(.deleted)
        case "c":
            executeVisualAction(.replaced)
        case "r":
            executeVisualAction(.refined)
        case "y":
            executeVisualYank()
        case "m":
            executeVisualMarkup()
            
        default: break
        }
    }
    
    private func executeVisualAction(_ type: SemanticChangeType) {
        guard let range = selectionRange, range.length > 0 else { return }
        let nsText = document.currentContent as NSString
        let selectedText = nsText.substring(with: range)
        
        if type == .deleted {
            let change = SemanticChange(
                type: .deleted, unitType: .sentence,
                beforeText: selectedText, position: range.location,
                context: "visual delete"
            )
            performDelete(range: range, change: change)
        } else {
            pendingChangeTracker.startChange(
                type: type, unitType: .sentence,
                beforeText: selectedText, position: range.location,
                context: "visual \(type.rawValue)"
            )
            performDelete(range: range, change: nil)
            mode = .insert(.sentence)
            insertContext = .sentence
        }
        selectionRange = nil
        if type == .deleted { mode = .normal }
    }
    
    private func executeVisualYank() {
        guard let range = selectionRange, range.length > 0 else { return }
        let nsText = document.currentContent as NSString
        document.yankRegister = nsText.substring(with: range)
        selectionRange = nil
        mode = .normal
    }
    
    private func executeVisualMarkup() {
        guard let range = selectionRange, range.length > 0 else { return }
        let nsText = document.currentContent as NSString
        annotationAnchorText = nsText.substring(with: range)
        annotationPosition = range.location
        selectionRange = nil
        mode = .normal
        showingAnnotationSheet = true
    }
    
    // MARK: - Command Mode
    
    private func handleCommandKey(_ chars: String, current: String) {
        guard let char = chars.first else { return }
        if char == "\u{1B}" { mode = .normal; return }
        if char == "\r" || char == "\n" { executeCommand(current); return }
        if char == "\u{7F}" {
            if current.isEmpty { mode = .normal }
            else { mode = .command(String(current.dropLast())) }
            return
        }
        mode = .command(current + String(char))
    }
    
    private func executeCommand(_ cmd: String) {
        let trimmed = cmd.trimmingCharacters(in: .whitespaces)
        let lower = trimmed.lowercased()
        
        switch lower {
        case "comp", "diff":
            enterCompMode()
        case "save", "commit":
            if document.currentBranchHead != nil { showingSaveSheet = true }
            mode = .normal
        case "hist", "log", "history":
            mode = .normal
        case "notes", "anno":
            mode = .normal
        case "branch", "branches", "explore":
            showingBranchSheet = true
            mode = .normal
        case "merge", "combine":
            showingMergeSheet = true
            mode = .normal
        case "help":
            mode = .normal
        default:
            // Check for :branch <name>
            if lower.hasPrefix("branch ") {
                let name = String(trimmed.dropFirst(7)).trimmingCharacters(in: .whitespaces)
                if !name.isEmpty {
                    document.createBranch(name: name)
                }
            }
            // Check for :checkout <name>
            else if lower.hasPrefix("checkout ") {
                let name = String(trimmed.dropFirst(9)).trimmingCharacters(in: .whitespaces)
                if !name.isEmpty {
                    document.switchBranch(to: name)
                    analyzer.invalidate()
                    debouncedUpdateStats()
                }
            }
            mode = .normal
        }
    }
    
    // MARK: - Comp Mode
    
    private func enterCompMode() {
        guard let headDraft = document.currentBranchHead else { mode = .normal; return }
        diffChanges = DiffGenerator.generateDiff(
            from: headDraft.content,
            to: document.currentContent,
            withChanges: document.sessionChanges
        )
        currentDiffIndex = 0
        mode = .comp
        if let first = DiffGenerator.getChangeIndices(in: diffChanges).first {
            currentDiffIndex = first
            if currentDiffIndex < diffChanges.count {
                cursorPosition = diffChanges[currentDiffIndex].range.location
            }
        }
    }
    
    private func handleCompKey(_ chars: String) {
        guard let char = chars.first else { return }
        switch char {
        case "\u{1B}":
            diffChanges = []
            mode = .normal
        case "n":
            if let next = DiffGenerator.findNextChange(from: currentDiffIndex, in: diffChanges) {
                currentDiffIndex = next
                navigateToCurrentDiffChange()
            }
        case "p":
            if let prev = DiffGenerator.findPreviousChange(from: currentDiffIndex, in: diffChanges) {
                currentDiffIndex = prev
                navigateToCurrentDiffChange()
            }
        default: break
        }
    }
    
    private func navigateToCurrentDiffChange() {
        guard currentDiffIndex < diffChanges.count else { return }
        let c = diffChanges[currentDiffIndex]
        cursorPosition = (c.type == .deletion ? c.displayRange?.location : c.range.location) ?? 0
    }
    
    // MARK: - Navigation
    
    private func navigateWord(forward: Bool) {
        let text = document.currentContent
        if forward {
            if let next = analyzer.nextWord(from: cursorPosition, in: text) {
                cursorPosition = next.range.location
            } else {
                cursorPosition = (text as NSString).length
            }
        } else {
            if let prev = analyzer.prevWord(from: cursorPosition, in: text) {
                cursorPosition = prev.range.location
            } else {
                cursorPosition = 0
            }
        }
        flashCursor()
    }
    
    private func navigateClause(forward: Bool) {
        let clauses = analyzer.clauses(in: document.currentContent)
        if forward {
            if let next = clauses.first(where: { $0.range.location > cursorPosition }) {
                cursorPosition = next.range.location
            }
        } else {
            if let prev = clauses.last(where: { $0.range.location < cursorPosition }) {
                cursorPosition = prev.range.location
            }
        }
        flashCursor()
    }
    
    private func navigateSentence(forward: Bool) {
        let text = document.currentContent
        if forward {
            if let next = analyzer.nextSentence(from: cursorPosition, in: text) {
                cursorPosition = next.range.location
            }
        } else {
            if let prev = analyzer.prevSentence(from: cursorPosition, in: text) {
                cursorPosition = prev.range.location
            }
        }
        flashCursor()
    }
    
    private func navigateParagraph(forward: Bool) {
        let nsText = document.currentContent as NSString
        if forward {
            let range = NSRange(location: cursorPosition, length: nsText.length - cursorPosition)
            let result = nsText.range(of: "\n\n", options: [], range: range)
            cursorPosition = result.location != NSNotFound
                ? result.location + result.length
                : nsText.length
        } else {
            let range = NSRange(location: 0, length: cursorPosition)
            let result = nsText.range(of: "\n\n", options: .backwards, range: range)
            if result.location != NSNotFound {
                if cursorPosition == result.location + result.length {
                    let subRange = NSRange(location: 0, length: result.location)
                    let prev = nsText.range(of: "\n\n", options: .backwards, range: subRange)
                    cursorPosition = prev.location != NSNotFound ? prev.location + prev.length : 0
                } else {
                    cursorPosition = result.location + result.length
                }
            } else {
                cursorPosition = 0
            }
        }
        flashCursor()
    }
    
    private func navigateLine(forward: Bool) {
        if forward {
            cursorPosition = TextAnalyzer.getNextLineStart(from: cursorPosition, in: document.currentContent)
        } else {
            cursorPosition = TextAnalyzer.getPreviousLineStart(from: cursorPosition, in: document.currentContent)
        }
        flashCursor()
    }
    
    // MARK: - Insert Helpers
    
    private func startInsert(context: InsertContext) {
        pendingChangeTracker.startChange(
            type: .added, unitType: .word,
            beforeText: nil, position: cursorPosition,
            context: "insert"
        )
        mode = .insert(context)
        insertContext = context
        pendingVerb = nil
        highlightRange = nil
    }
    
    // MARK: - Core Helpers
    
    private func performDelete(range: NSRange, change: SemanticChange?) {
        let nsText = document.currentContent as NSString
        let safeRange = TextAnalyzer.safeRange(range, in: nsText.length)
        guard safeRange.length > 0 else { return }
        
        let deletedText = nsText.substring(with: safeRange)
        let afterContent = nsText.replacingCharacters(in: safeRange, with: "")
        
        let operation = DeleteOperation(
            range: safeRange,
            deletedText: deletedText,
            cursorBefore: cursorPosition,
            semanticChange: change
        )
        undoStack.push(operation)
        
        document.currentContent = afterContent
        cursorPosition = safeRange.location
        if let change = change { document.recordChange(change) }
        handleTextChange()
    }
    
    private func highlightRangeBriefly(_ range: NSRange, completion: @escaping () -> Void) {
        highlightRange = range
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
            self.highlightRange = nil
            completion()
        }
    }
    
    private func flashUnit(_ unit: TextUnit) {
        flashRange = unit.range
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.12) { self.flashRange = nil }
    }
    
    private func flashCursor() {
        let text = document.currentContent
        guard !text.isEmpty else { return }
        let loc = TextAnalyzer.safePosition(cursorPosition, in: text)
        let len = loc < (text as NSString).length ? 1 : 0
        flashRange = NSRange(location: loc, length: len)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.12) { self.flashRange = nil }
    }
}

// MARK: - Move Indicator

struct MoveIndicator: View {
    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: "arrow.up.arrow.down")
            Text("MOVING — j/k to position, Enter to confirm, ESC to cancel")
                .font(.system(size: 11, weight: .medium))
        }
        .foregroundColor(.white)
        .padding(.horizontal, 10)
        .padding(.vertical, 6)
        .background(Color.purple)
        .cornerRadius(6)
    }
}

==================================================
FILE: Thesis/StatusBar.swift
==================================================

// StatusBar.swift — Thesis
// Bottom status bar showing mode, stats, and contextual info

import SwiftUI

struct StatusBar: View {
    let mode: EditorMode
    let pendingVerb: EditVerb?
    let stats: TextAnalyzer.Stats
    let draftInfo: String
    let hasUnsavedChanges: Bool
    let branchInfo: String?
    let diffInfo: EditorDiffInfo?
    let undoPreview: String?
    let annotationCount: Int
    let sessionSummary: String
    
    var body: some View {
        HStack(spacing: 12) {
            Text(modeDisplayText)
                .font(.system(size: 11, weight: .bold, design: .monospaced))
                .foregroundColor(.white)
                .padding(.horizontal, 8)
                .padding(.vertical, 3)
                .background(mode.statusColor)
                .cornerRadius(4)
            
            Group {
                if let diff = diffInfo {
                    diffInfoView(diff)
                } else if let verb = pendingVerb {
                    verbPendingView(verb)
                } else {
                    defaultInfoView
                }
            }
            
            Spacer()
            
            if annotationCount > 0 {
                HStack(spacing: 2) {
                    Image(systemName: "note.text")
                        .font(.system(size: 10))
                    Text("\(annotationCount)")
                        .font(.system(size: 10, weight: .medium, design: .monospaced))
                }
                .foregroundColor(.purple)
                .padding(.horizontal, 6)
                .padding(.vertical, 2)
                .background(Color.purple.opacity(0.1))
                .cornerRadius(3)
            }
            
            HStack(spacing: 12) {
                Text("\(stats.paragraphCount) ¶")
                Text("\(stats.sentenceCount) S")
                Text("\(stats.wordCount) W")
            }
            .font(.system(size: 11, design: .monospaced))
            .foregroundColor(.secondary)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(Color(NSColor.controlBackgroundColor))
    }
    
    private var modeDisplayText: String {
        if let verb = pendingVerb {
            return "\(mode.displayName) → \(verb.displayName)…"
        }
        if case .command(let text) = mode {
            return ":\(text)"
        }
        return mode.displayName
    }
    
    private func diffInfoView(_ diff: EditorDiffInfo) -> some View {
        HStack(spacing: 8) {
            Text("Change \(diff.currentIndex + 1)/\(diff.totalChanges)")
                .font(.system(size: 11, design: .monospaced))
            if let change = diff.currentChange { changeBadge(for: change) }
            Text("n: next  p: prev  ESC: exit")
                .font(.system(size: 10))
                .foregroundColor(.secondary)
        }
    }
    
    private func changeBadge(for change: DiffChange) -> some View {
        Group {
            switch change.type {
            case .addition:
                let label = change.semanticType?.displayName.uppercased() ?? "ADDED"
                let color: Color = {
                    switch change.semanticType {
                    case .refined:  return .blue
                    case .replaced: return .orange
                    default:        return .green
                    }
                }()
                Text(label).font(.system(size: 10, weight: .bold))
                    .foregroundColor(.white).padding(.horizontal, 6).padding(.vertical, 2)
                    .background(color).cornerRadius(3)
            case .deletion:
                let preview = String(change.text.prefix(40))
                Text("DELETED: \"\(preview)\"")
                    .font(.system(size: 10)).foregroundColor(.white)
                    .padding(.horizontal, 6).padding(.vertical, 2)
                    .background(Color.red).cornerRadius(3).lineLimit(1)
            case .moved:
                Text("MOVED").font(.system(size: 10, weight: .bold))
                    .foregroundColor(.white).padding(.horizontal, 6).padding(.vertical, 2)
                    .background(Color.purple).cornerRadius(3)
            case .unchanged:
                EmptyView()
            }
        }
    }
    
    private func verbPendingView(_ verb: EditVerb) -> some View {
        HStack(spacing: 8) {
            Text("Waiting for object:")
                .font(.system(size: 11)).foregroundColor(.secondary)
            ForEach(verb.helpItems.prefix(5), id: \.key) { item in
                HStack(spacing: 2) {
                    Text(item.key).font(.system(size: 11, weight: .bold, design: .monospaced))
                    Text(item.description).font(.system(size: 10)).foregroundColor(.secondary)
                }
            }
        }
    }
    
    private var defaultInfoView: some View {
        HStack(spacing: 8) {
            Text(draftInfo)
                .font(.system(size: 11, design: .monospaced))
                .foregroundColor(hasUnsavedChanges ? .orange : .secondary)
            if hasUnsavedChanges {
                Text("•").font(.system(size: 14, weight: .bold)).foregroundColor(.orange)
            }
            if let branch = branchInfo {
                Text(branch)
                    .font(.system(size: 11, design: .monospaced))
                    .foregroundColor(.purple)
                    .padding(.horizontal, 8).padding(.vertical, 2)
                    .background(Color.purple.opacity(0.15))
                    .cornerRadius(4)
            }
        }
    }
}

// MARK: - Verb Help Overlay

struct VerbHelpOverlay: View {
    let verb: EditVerb
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(verb.displayName)
                .font(.system(size: 12, weight: .bold, design: .monospaced))
            Divider()
            ForEach(verb.helpItems, id: \.key) { item in
                HStack(spacing: 8) {
                    Text(item.key)
                        .font(.system(size: 12, weight: .bold, design: .monospaced))
                        .frame(width: 16, alignment: .center)
                        .foregroundColor(verb == .delete ? .red : verb == .refine ? .blue : .primary)
                    Text(item.description)
                        .font(.system(size: 11))
                        .foregroundColor(.secondary)
                }
            }
            Divider()
            Text("ESC to cancel")
                .font(.system(size: 10))
                .foregroundColor(.secondary)
        }
        .padding(10)
        .background(.ultraThinMaterial)
        .cornerRadius(8)
        .shadow(color: .black.opacity(0.15), radius: 8, y: 2)
    }
}

==================================================
FILE: Thesis/DraftHistoryView.swift
==================================================

// DraftHistoryView.swift — Thesis
// Version history sidebar: commits (branch-aware), darlings, annotations (with categories)

import SwiftUI

struct DraftHistoryView: View {
    @ObservedObject var document: Document
    let onRestore: (Draft) -> Void
    let onNavigateToAnnotation: ((Annotation) -> Void)?
    let onClose: () -> Void
    
    @State private var selectedTab: HistoryTab = .commits
    @State private var editingAnnotation: Annotation?
    @State private var editText: String = ""
    
    enum HistoryTab: String, CaseIterable {
        case commits = "History"
        case darlings = "Darlings"
        case annotations = "Notes"
    }
    
    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Text("Evolution").font(.headline)
                Spacer()
                Button(action: onClose) {
                    Image(systemName: "xmark.circle.fill").foregroundColor(.secondary)
                }.buttonStyle(.borderless)
            }
            .padding(.horizontal, 12).padding(.vertical, 8)
            
            Picker("", selection: $selectedTab) {
                ForEach(HistoryTab.allCases, id: \.self) { Text($0.rawValue).tag($0) }
            }
            .pickerStyle(.segmented)
            .padding(.horizontal, 12).padding(.bottom, 8)
            
            Divider()
            
            switch selectedTab {
            case .commits:    commitsView
            case .darlings:   darlingsView
            case .annotations: annotationsView
            }
        }
        .background(Color(NSColor.controlBackgroundColor))
    }
    
    // MARK: - Commits
    
    private var commitsView: some View {
        ScrollView {
            LazyVStack(spacing: 0) {
                // Branch indicator
                if document.branches.count > 1 {
                    branchIndicator
                    Divider().padding(.horizontal, 12)
                }
                
                if document.hasUnsavedChanges {
                    sessionCard
                    Divider().padding(.horizontal, 12)
                }
                
                let branchDrafts = document.currentBranchDrafts.reversed()
                ForEach(Array(branchDrafts)) { draft in
                    draftCard(draft)
                    Divider().padding(.horizontal, 12)
                }
                
                if document.drafts.isEmpty {
                    emptyState("No commits yet", subtitle: "Press ESC in Free Text mode to save your first draft.")
                }
            }
        }
    }
    
    private var branchIndicator: some View {
        HStack {
            Image(systemName: "arrow.triangle.branch").font(.system(size: 12))
                .foregroundColor(.purple)
            Text(document.activeBranchName)
                .font(.system(size: 12, weight: .semibold, design: .monospaced))
            Text("(\(document.branches.count) branches)")
                .font(.system(size: 11)).foregroundColor(.secondary)
        }
        .padding(12)
    }
    
    private var sessionCard: some View {
        VStack(alignment: .leading, spacing: 6) {
            HStack {
                Circle().fill(Color.orange).frame(width: 8, height: 8)
                Text("Working Draft").font(.system(size: 12, weight: .semibold))
                Spacer()
                Text("unsaved").font(.system(size: 10)).foregroundColor(.orange)
            }
            if !document.sessionChanges.isEmpty {
                Text(document.sessionChangeSummary).font(.system(size: 11)).foregroundColor(.secondary)
                ForEach(document.sessionChanges.suffix(5)) { change in
                    changeRow(change)
                }
                if document.sessionChanges.count > 5 {
                    Text("+ \(document.sessionChanges.count - 5) more")
                        .font(.system(size: 10)).foregroundColor(.secondary)
                }
            }
        }
        .padding(12)
    }
    
    private func draftCard(_ draft: Draft) -> some View {
        VStack(alignment: .leading, spacing: 6) {
            HStack {
                Image(systemName: draft.isMergeCommit ? "arrow.triangle.merge" :
                        draft.isFirstDraft ? "flag.fill" : "circle.fill")
                    .font(.system(size: 8))
                    .foregroundColor(draft.isFirstDraft ? .green : draft.isMergeCommit ? .purple : .blue)
                Text(draft.displayName).font(.system(size: 12, weight: .semibold)).lineLimit(1)
                Spacer()
                Text(draft.displayTimestamp).font(.system(size: 10)).foregroundColor(.secondary)
            }
            if !draft.comment.isEmpty {
                Text(draft.comment).font(.system(size: 11)).foregroundColor(.secondary).lineLimit(2)
            }
            if !draft.changes.isEmpty {
                HStack(spacing: 6) {
                    ForEach(ChangeSummary(changes: draft.changes).breakdown, id: \.type) { item in
                        HStack(spacing: 2) {
                            Image(systemName: item.type.icon).font(.system(size: 9))
                            Text("\(item.count)").font(.system(size: 10, weight: .medium))
                        }
                        .foregroundColor(colorForSemanticType(item.type.color))
                    }
                }
            }
            Button("Restore") { onRestore(draft) }
                .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.blue)
        }
        .padding(12)
    }
    
    private func changeRow(_ change: SemanticChange) -> some View {
        HStack(spacing: 6) {
            Image(systemName: change.type.icon).font(.system(size: 10))
                .foregroundColor(colorForSemanticType(change.type.color))
            Text(change.summary).font(.system(size: 10, weight: .medium))
            Text(change.displayText).font(.system(size: 10)).foregroundColor(.secondary).lineLimit(1)
        }
    }
    
    // MARK: - Darlings
    
    private var darlingsView: some View {
        ScrollView {
            LazyVStack(spacing: 0) {
                let darlings = document.allDarlings
                if darlings.isEmpty {
                    emptyState("No darlings yet",
                               subtitle: "Deleted and replaced text will appear here. You'll never lose a word.")
                } else {
                    ForEach(Array(darlings.enumerated()), id: \.offset) { _, darling in
                        darlingCard(text: darling.text, draft: darling.draft, date: darling.date)
                        Divider().padding(.horizontal, 12)
                    }
                }
            }
        }
    }
    
    private func darlingCard(text: String, draft: String, date: Date) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Image(systemName: "text.badge.minus").font(.system(size: 10)).foregroundColor(.red)
                Text(draft).font(.system(size: 10, weight: .medium)).foregroundColor(.secondary)
                Spacer()
                Text(date, style: .relative).font(.system(size: 10)).foregroundColor(.secondary)
            }
            Text(text).font(.system(size: 12)).lineLimit(4).textSelection(.enabled)
            Button("Copy") {
                NSPasteboard.general.clearContents()
                NSPasteboard.general.setString(text, forType: .string)
            }
            .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.blue)
        }
        .padding(12)
    }
    
    // MARK: - Annotations (with categories, edit, navigate)
    
    private var annotationsView: some View {
        ScrollView {
            LazyVStack(spacing: 0) {
                if document.annotations.isEmpty {
                    emptyState("No notes yet", subtitle: "Press m + object in Normal mode to annotate text.")
                } else {
                    // Group by category
                    let grouped = document.annotationsByCategory
                    let orderedCategories = AnnotationCategory.allCases.filter { grouped[$0] != nil }
                    
                    ForEach(orderedCategories, id: \.self) { category in
                        if let annotations = grouped[category] {
                            categoryHeader(category, count: annotations.count)
                            ForEach(annotations) { annotation in
                                annotationCard(annotation)
                                Divider().padding(.horizontal, 12)
                            }
                        }
                    }
                    
                    // Resolved annotations
                    let resolved = document.annotations.filter(\.resolved)
                    if !resolved.isEmpty {
                        categoryHeader(nil, count: resolved.count, label: "Resolved")
                        ForEach(resolved) { annotation in
                            annotationCard(annotation)
                            Divider().padding(.horizontal, 12)
                        }
                    }
                }
            }
        }
    }
    
    private func categoryHeader(_ category: AnnotationCategory?, count: Int, label: String? = nil) -> some View {
        HStack {
            if let cat = category {
                Image(systemName: cat.icon).font(.system(size: 11))
                    .foregroundColor(colorForSemanticType(cat.color))
                Text(cat.displayName).font(.system(size: 12, weight: .semibold))
            } else {
                Image(systemName: "checkmark.circle").font(.system(size: 11)).foregroundColor(.green)
                Text(label ?? "").font(.system(size: 12, weight: .semibold))
            }
            Text("(\(count))").font(.system(size: 11)).foregroundColor(.secondary)
            Spacer()
        }
        .padding(.horizontal, 12).padding(.vertical, 6)
        .background(Color.secondary.opacity(0.05))
    }
    
    private func annotationCard(_ annotation: Annotation) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Image(systemName: annotation.resolved ? "checkmark.circle.fill" : annotation.category.icon)
                    .font(.system(size: 10))
                    .foregroundColor(annotation.resolved ? .green : colorForSemanticType(annotation.category.color))
                Text(annotation.displayTimestamp).font(.system(size: 10)).foregroundColor(.secondary)
                
                if annotation.isStale {
                    Text("stale").font(.system(size: 9, weight: .medium))
                        .foregroundColor(.orange).padding(.horizontal, 4).padding(.vertical, 1)
                        .background(Color.orange.opacity(0.1)).cornerRadius(3)
                }
                
                Spacer()
                
                // Navigate button
                Button {
                    onNavigateToAnnotation?(annotation)
                } label: {
                    Image(systemName: "location").font(.system(size: 10))
                }
                .buttonStyle(.borderless).foregroundColor(.blue)
            }
            
            Text("on: \"\(String(annotation.anchorText.prefix(60)))\"")
                .font(.system(size: 10, design: .monospaced))
                .foregroundColor(.secondary).lineLimit(1)
            
            if editingAnnotation?.id == annotation.id {
                HStack {
                    TextField("Edit note", text: $editText)
                        .textFieldStyle(.roundedBorder).font(.system(size: 11))
                    Button("Save") {
                        document.updateAnnotation(annotation.id, text: editText)
                        editingAnnotation = nil
                    }
                    .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.blue)
                }
            } else {
                Text(annotation.text).font(.system(size: 12))
                    .opacity(annotation.resolved ? 0.5 : 1)
            }
            
            HStack(spacing: 8) {
                if !annotation.resolved {
                    Button("Resolve") { document.resolveAnnotation(annotation) }
                        .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.green)
                    Button("Edit") {
                        editText = annotation.text
                        editingAnnotation = annotation
                    }
                    .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.blue)
                } else {
                    Button("Reopen") { document.unresolveAnnotation(annotation) }
                        .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.orange)
                }
                Button("Delete") { document.deleteAnnotation(annotation) }
                    .font(.system(size: 10)).buttonStyle(.borderless).foregroundColor(.red)
            }
        }
        .padding(12)
    }
    
    private func emptyState(_ title: String, subtitle: String) -> some View {
        VStack(spacing: 8) {
            Text(title).font(.system(size: 13, weight: .medium)).foregroundColor(.secondary)
            Text(subtitle).font(.system(size: 11)).foregroundColor(.secondary).multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity).padding(24)
    }
}

==================================================
FILE: Thesis/Sheets.swift
==================================================

// Sheets.swift — Thesis
// Modal sheets: FirstDraft, SaveDraft, Annotation (with categories), Branch, Merge

import SwiftUI

// MARK: - First Draft Sheet

struct FirstDraftSheet: View {
    @State private var draftName: String = ""
    let onSave: (String) -> Void
    let onCancel: () -> Void
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "flag.fill").font(.system(size: 28)).foregroundColor(.green)
            Text("Save First Draft").font(.headline)
            Text("This becomes the baseline for tracking how your thinking evolves.")
                .font(.subheadline).foregroundColor(.secondary).multilineTextAlignment(.center)
            TextField("Name (optional — auto-named if empty)", text: $draftName)
                .textFieldStyle(.roundedBorder)
                .onSubmit { dismiss(); onSave(draftName) }
            HStack(spacing: 12) {
                Button("Cancel") { dismiss(); onCancel() }.keyboardShortcut(.escape)
                Button("Save") { dismiss(); onSave(draftName) }
                    .keyboardShortcut(.return).buttonStyle(.borderedProminent)
            }
        }
        .padding(24).frame(width: 420)
    }
}

// MARK: - Save Draft Sheet

struct SaveDraftSheet: View {
    let sessionSummary: String
    let onSave: (String, String) -> Void
    @State private var draftName: String = ""
    @State private var comment: String = ""
    @FocusState private var focusedField: Field?
    @Environment(\.dismiss) var dismiss
    enum Field { case name, comment }
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "square.and.arrow.down").font(.system(size: 28)).foregroundColor(.blue)
            Text("Save Draft").font(.headline)
            if sessionSummary != "No changes" {
                Text(sessionSummary).font(.system(size: 12, design: .monospaced))
                    .foregroundColor(.secondary).padding(8)
                    .background(Color.secondary.opacity(0.1)).cornerRadius(6)
            }
            TextField("Draft name", text: $draftName)
                .textFieldStyle(.roundedBorder).focused($focusedField, equals: .name)
                .onSubmit { focusedField = .comment }
            TextField("What changed in your thinking?", text: $comment)
                .textFieldStyle(.roundedBorder).focused($focusedField, equals: .comment)
                .onSubmit { if !draftName.isEmpty && !comment.isEmpty { dismiss(); onSave(draftName, comment) } }
            HStack(spacing: 12) {
                Button("Cancel") { dismiss() }.keyboardShortcut(.escape)
                Button("Save") { dismiss(); onSave(draftName, comment) }
                    .disabled(draftName.isEmpty || comment.isEmpty)
                    .keyboardShortcut(.return).buttonStyle(.borderedProminent)
            }
        }
        .padding(24).frame(width: 420).onAppear { focusedField = .name }
    }
}

// MARK: - Annotation Sheet (with categories)

struct AnnotationSheet: View {
    let anchorText: String
    let onSave: (String, AnnotationCategory) -> Void
    @State private var noteText: String = ""
    @State private var category: AnnotationCategory = .note
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "note.text").font(.system(size: 28)).foregroundColor(.purple)
            Text("Add Note").font(.headline)
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Annotating:").font(.system(size: 11, weight: .medium)).foregroundColor(.secondary)
                Text("\"\(String(anchorText.prefix(100)))\(anchorText.count > 100 ? "…" : "")\"")
                    .font(.system(size: 12)).padding(8)
                    .background(Color.purple.opacity(0.05)).cornerRadius(6)
            }
            
            // Category picker
            Picker("Category", selection: $category) {
                ForEach(AnnotationCategory.allCases, id: \.self) { cat in
                    Label(cat.displayName, systemImage: cat.icon).tag(cat)
                }
            }
            .pickerStyle(.segmented)
            
            TextField("Your note…", text: $noteText, axis: .vertical)
                .textFieldStyle(.roundedBorder).lineLimit(3...6)
                .onSubmit { if !noteText.isEmpty { dismiss(); onSave(noteText, category) } }
            
            HStack(spacing: 12) {
                Button("Cancel") { dismiss() }.keyboardShortcut(.escape)
                Button("Save Note") { dismiss(); onSave(noteText, category) }
                    .disabled(noteText.isEmpty)
                    .keyboardShortcut(.return).buttonStyle(.borderedProminent)
            }
        }
        .padding(24).frame(width: 440)
    }
}

// MARK: - Branch Sheet

struct BranchSheet: View {
    @ObservedObject var document: Document
    let onCreateBranch: (String, String) -> Void
    let onSwitchBranch: (String) -> Void
    let onDeleteBranch: (String) -> Void
    
    @State private var newBranchName: String = ""
    @State private var branchDescription: String = ""
    @State private var showingCreate = false
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "arrow.triangle.branch").font(.system(size: 28)).foregroundColor(.purple)
            Text("Branches").font(.headline)
            
            // Existing branches
            ScrollView {
                VStack(spacing: 4) {
                    ForEach(document.branches) { branch in
                        HStack {
                            Image(systemName: branch.name == document.activeBranchName ? "checkmark.circle.fill" : "circle")
                                .foregroundColor(branch.name == document.activeBranchName ? .green : .secondary)
                            VStack(alignment: .leading) {
                                Text(branch.name).font(.system(size: 13, weight: .medium))
                                if !branch.description.isEmpty {
                                    Text(branch.description).font(.system(size: 11)).foregroundColor(.secondary)
                                }
                            }
                            Spacer()
                            if branch.name != document.activeBranchName {
                                Button("Switch") { dismiss(); onSwitchBranch(branch.name) }
                                    .font(.system(size: 11)).buttonStyle(.borderless)
                                if branch.name != "main" {
                                    Button("Delete") { onDeleteBranch(branch.name) }
                                        .font(.system(size: 11)).buttonStyle(.borderless).foregroundColor(.red)
                                }
                            }
                        }
                        .padding(8)
                        .background(branch.name == document.activeBranchName ? Color.green.opacity(0.05) : Color.clear)
                        .cornerRadius(6)
                    }
                }
            }
            .frame(maxHeight: 200)
            
            Divider()
            
            // Create new branch
            if showingCreate {
                VStack(spacing: 8) {
                    TextField("Branch name", text: $newBranchName).textFieldStyle(.roundedBorder)
                    TextField("Description (optional)", text: $branchDescription).textFieldStyle(.roundedBorder)
                    HStack {
                        Button("Cancel") { showingCreate = false }.buttonStyle(.borderless)
                        Button("Create") {
                            if !newBranchName.isEmpty {
                                dismiss()
                                onCreateBranch(newBranchName, branchDescription)
                            }
                        }
                        .buttonStyle(.borderedProminent)
                        .disabled(newBranchName.isEmpty)
                    }
                }
            } else {
                Button("New Branch") { showingCreate = true }.buttonStyle(.borderedProminent)
            }
            
            Button("Close") { dismiss() }.keyboardShortcut(.escape)
        }
        .padding(24).frame(width: 400)
    }
}

// MARK: - Merge Sheet

struct MergeSheet: View {
    @ObservedObject var document: Document
    let onMerge: (String) -> Void
    
    @State private var selectedBranch: String = ""
    @Environment(\.dismiss) var dismiss
    
    var mergeCandidates: [Branch] {
        document.branches.filter { $0.name != document.activeBranchName }
    }
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "arrow.triangle.merge").font(.system(size: 28)).foregroundColor(.blue)
            Text("Merge Branch").font(.headline)
            Text("Merge another branch into '\(document.activeBranchName)'")
                .font(.subheadline).foregroundColor(.secondary)
            
            if mergeCandidates.isEmpty {
                Text("No other branches to merge.").foregroundColor(.secondary).padding()
            } else {
                Picker("Source branch", selection: $selectedBranch) {
                    Text("Select…").tag("")
                    ForEach(mergeCandidates) { branch in
                        Text(branch.name).tag(branch.name)
                    }
                }
                .onAppear { selectedBranch = mergeCandidates.first?.name ?? "" }
            }
            
            HStack(spacing: 12) {
                Button("Cancel") { dismiss() }.keyboardShortcut(.escape)
                Button("Merge") { dismiss(); onMerge(selectedBranch) }
                    .disabled(selectedBranch.isEmpty)
                    .keyboardShortcut(.return).buttonStyle(.borderedProminent)
            }
        }
        .padding(24).frame(width: 400)
    }
}

==================================================
FILE: Thesis/ContentView.swift
==================================================

// ContentView.swift — Thesis
// Main layout: sidebar, editor, history panel

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var documentManager: DocumentManager
    @State private var showingHistory = false
    
    var body: some View {
        HSplitView {
            DocumentSidebar(
                documents: documentManager.documents,
                selectedDocument: $documentManager.selectedDocument,
                onNewDocument: { documentManager.createNewDocument() },
                onDeleteDocument: { doc in documentManager.deleteDocument(doc) }
            )
            .frame(minWidth: 220, idealWidth: 260, maxWidth: 320)
            
            if let document = documentManager.selectedDocument {
                EditorContainer(
                    document: document,
                    showingHistory: $showingHistory,
                    onSave: { documentManager.saveDocuments() }
                )
            } else {
                EmptyStateView(onNewDocument: { documentManager.createNewDocument() })
            }
        }
        .onChange(of: documentManager.selectedDocument) {
            documentManager.saveDocuments()
        }
    }
}

// MARK: - Document Sidebar

struct DocumentSidebar: View {
    let documents: [Document]
    @Binding var selectedDocument: Document?
    let onNewDocument: () -> Void
    let onDeleteDocument: (Document) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack {
                Text("Thoughts").font(.headline)
                Spacer()
                Button(action: onNewDocument) { Image(systemName: "plus") }
                    .buttonStyle(.borderless).keyboardShortcut("n", modifiers: [.command])
            }
            .padding()
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            List(documents) { doc in
                DocumentListItem(document: doc, isSelected: selectedDocument?.id == doc.id)
                    .contentShape(Rectangle())
                    .onTapGesture { selectedDocument = doc }
                    .contextMenu {
                        Button("Delete", role: .destructive) { onDeleteDocument(doc) }
                    }
            }
            .listStyle(.sidebar)
        }
    }
}

struct DocumentListItem: View {
    @ObservedObject var document: Document
    let isSelected: Bool
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(document.title)
                    .font(.system(size: 13, weight: isSelected ? .semibold : .regular))
                if document.hasUnsavedChanges {
                    Circle().fill(Color.orange).frame(width: 6, height: 6)
                }
                if document.branches.count > 1 {
                    Image(systemName: "arrow.triangle.branch")
                        .font(.system(size: 9)).foregroundColor(.purple)
                }
            }
            HStack {
                if let latest = document.currentBranchHead {
                    Text(latest.name).font(.system(size: 11)).foregroundColor(.secondary).lineLimit(1)
                } else {
                    Text("No draft").font(.system(size: 11)).foregroundColor(.secondary)
                }
                Spacer()
                Text(document.lastModified, style: .relative)
                    .font(.system(size: 10)).foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 4)
    }
}

// MARK: - Editor Container

struct EditorContainer: View {
    @ObservedObject var document: Document
    @Binding var showingHistory: Bool
    let onSave: () -> Void
    
    var body: some View {
        VStack(spacing: 0) {
            HStack {
                TextField("Thought title", text: $document.title)
                    .textFieldStyle(.plain).font(.title2).padding()
                Spacer()
                Button(action: { showingHistory.toggle() }) {
                    Label(showingHistory ? "Hide Panel" : "Evolution",
                          systemImage: showingHistory ? "sidebar.right" : "clock")
                }
                .buttonStyle(.borderless).padding(.trailing)
                .keyboardShortcut("e", modifiers: [.command])
            }
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            HSplitView {
                ModalEditor(document: .constant(document))
                    .frame(minWidth: 500)
                
                if showingHistory {
                    DraftHistoryView(
                        document: document,
                        onRestore: { draft in
                            document.restoreDraft(draft)
                            onSave()
                        },
                        onNavigateToAnnotation: { annotation in
                            // Navigation would scroll the editor to the annotation's position
                            // For now this is wired through as a callback
                        },
                        onClose: { showingHistory = false }
                    )
                    .frame(minWidth: 280, idealWidth: 340, maxWidth: 400)
                }
            }
        }
    }
}

// MARK: - Empty State

struct EmptyStateView: View {
    let onNewDocument: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "text.cursor").font(.system(size: 64)).foregroundColor(.secondary)
            Text("No Thought Selected").font(.title2).foregroundColor(.secondary)
            Text("Create a new thought or select one from the sidebar.")
                .font(.body).foregroundColor(.secondary).multilineTextAlignment(.center)
            Button(action: onNewDocument) {
                Label("New Thought", systemImage: "plus.circle.fill").font(.headline)
            }
            .buttonStyle(.borderedProminent)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// MARK: - Color Helper

func colorForSemanticType(_ name: String) -> Color {
    switch name {
    case "green":  return .green
    case "red":    return .red
    case "orange": return .orange
    case "blue":   return .blue
    case "purple": return .purple
    case "yellow": return .yellow
    default:       return .primary
    }
}

==================================================
FILE: Thesis/ThesisApp.swift
==================================================

// ThesisApp.swift — Thesis
// Application entry point

import SwiftUI

@main
struct ThesisApp: App {
    @StateObject private var documentManager = DocumentManager()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(documentManager)
                .frame(minWidth: 900, minHeight: 600)
        }
        .windowStyle(.titleBar)
        .commands {
            CommandGroup(replacing: .newItem) {
                Button("New Thought") { documentManager.createNewDocument() }
                    .keyboardShortcut("n", modifiers: [.command])
            }
            CommandGroup(replacing: .saveItem) {
                Button("Save Documents") { documentManager.saveDocuments() }
                    .keyboardShortcut("s", modifiers: [.command, .shift])
            }
        }
    }
}

